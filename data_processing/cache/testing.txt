<!doctype html><html lang=en class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.101.0"><link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Concepts | Kubernetes</title><meta property="og:title" content="Concepts"><meta property="og:description" content="Production-Grade Container Orchestration"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Concepts"><meta itemprop=description content="Production-Grade Container Orchestration"><meta name=twitter:card content="summary"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="Production-Grade Container Orchestration"><script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JPP6RFM2BP",{anonymize_ip:!1})}</script><link rel=preload href=/scss/main.min.46665d0fd04f795bd20d2ece9b5eb8c7c0cee876f556a0be26671881c6769241.css as=style><link href=/scss/main.min.46665d0fd04f795bd20d2ece9b5eb8c7c0cee876f556a0be26671881c6769241.css rel=stylesheet integrity><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="The Concepts section helps you learn about the parts of the Kubernetes system and the abstractions Kubernetes uses to represent your cluster, and helps you obtain a deeper understanding of how Kubernetes works."><meta property="og:description" content="The Concepts section helps you learn about the parts of the Kubernetes system and the abstractions Kubernetes uses to represent your cluster, and helps you obtain a deeper understanding of how Kubernetes works."><meta name=twitter:description content="The Concepts section helps you learn about the parts of the Kubernetes system and the abstractions Kubernetes uses to represent your cluster, and helps you obtain a deeper understanding of how Kubernetes works."><meta property="og:url" content="https://kubernetes.io/docs/concepts/"><meta property="og:title" content="Concepts"><meta name=twitter:title content="Concepts"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class="navbar-brand img-fluid" href=/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/docs/>Documentation</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/training/>Training</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/partners/>Partners</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/case-studies/>Case Studies</a></li><li class="nav-item mr-n3 mr-lg-0 dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/>v1.22</a></div></li><li class="nav-item mr-n4 mr-lg-0 dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/docs/concepts/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/concepts/>Return to the regular view of this page</a>.</p></div><h1 class=title>Concepts</h1><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Overview</a></li><ul><li>1.1: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Kubernetes Components</a></li><li>1.2: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>The Kubernetes API</a></li><li>1.3: <a href=#pg-110f33530cf761140cb1dab536baef04>Working with Kubernetes Objects</a></li><ul><li>1.3.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Understanding Kubernetes Objects</a></li><li>1.3.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Kubernetes Object Management</a></li><li>1.3.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Object Names and IDs</a></li><li>1.3.4: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Labels and Selectors</a></li><li>1.3.5: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespaces</a></li><li>1.3.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Annotations</a></li><li>1.3.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Field Selectors</a></li><li>1.3.8: <a href=#pg-13ce5627ef1dc8cbb4530ed231cb7d38>Finalizers</a></li><li>1.3.9: <a href=#pg-efaa7a58910b58892dafd50e3b43c93c>Owners and Dependents</a></li><li>1.3.10: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Recommended Labels</a></li></ul></ul><li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Cluster Architecture</a></li><ul><li>2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Nodes</a></li><li>2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Communication between Nodes and the Control Plane</a></li><li>2.3: <a href=#pg-ca8819042a505291540e831283da66df>Controllers</a></li><li>2.4: <a href=#pg-d5e64235fa89f107957072cd8a39e4c5>Leases</a></li><li>2.5: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Cloud Controller Manager</a></li><li>2.6: <a href=#pg-c20ec7d296cc2c8668bb204c2af31180>About cgroup v2</a></li><li>2.7: <a href=#pg-c0ea5310f52e22c5de34dc84d9ab5e0d>Container Runtime Interface (CRI)</a></li><li>2.8: <a href=#pg-44a2e2e592af0846101e970aff9243e5>Garbage Collection</a></li></ul><li>3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Containers</a></li><ul><li>3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>Images</a></li><li>3.2: <a href=#pg-643212488f778acf04bebed65ba34441>Container Environment</a></li><li>3.3: <a href=#pg-a858027489648786a3b16264e451272b>Runtime Class</a></li><li>3.4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Container Lifecycle Hooks</a></li></ul><li>4: <a href=#pg-05a1231ecbfe48ec554e6d078818aca4>Windows in Kubernetes</a></li><ul><li>4.1: <a href=#pg-849246a35c3de66980f66e1b0944ceb4>Windows containers in Kubernetes</a></li><li>4.2: <a href=#pg-0d8bfd3be43b3580681c56f6fec9d6dc>Guide for scheduling Windows containers in Kubernetes</a></li></ul><li>5: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>Workloads</a></li><ul><li>5.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pods</a></li><ul><li>5.1.1: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Pod Lifecycle</a></li><li>5.1.2: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Init Containers</a></li><li>5.1.3: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>Disruptions</a></li><li>5.1.4: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>Ephemeral Containers</a></li><li>5.1.5: <a href=#pg-a77cbc10142789b7e0f78a222546ed1e>Pod Quality of Service Classes</a></li><li>5.1.6: <a href=#pg-868be91dc02aab6dc768102e4abf5eff>User Namespaces</a></li><li>5.1.7: <a href=#pg-420713565efe2f940e277f6b4824ad9a>Downward API</a></li></ul><li>5.2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>Workload Resources</a></li><ul><li>5.2.1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Deployments</a></li><li>5.2.2: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li><li>5.2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSets</a></li><li>5.2.4: <a href=#pg-41600eb8b6631c88848156f381e9d588>DaemonSet</a></li><li>5.2.5: <a href=#pg-cc7cc3c4907039d9f863162e20bfbbef>Jobs</a></li><li>5.2.6: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>Automatic Cleanup for Finished Jobs</a></li><li>5.2.7: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>CronJob</a></li><li>5.2.8: <a href=#pg-27f1331d515d95f76aa1156088b4ad91>ReplicationController</a></li></ul></ul><li>6: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Services, Load Balancing, and Networking</a></li><ul><li>6.1: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li><li>6.2: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li><li>6.3: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>Ingress Controllers</a></li><li>6.4: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlices</a></li><li>6.5: <a href=#pg-ded1daafdcd293023ee333728007ca61>Network Policies</a></li><li>6.6: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>DNS for Services and Pods</a></li><li>6.7: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>IPv4/IPv6 dual-stack</a></li><li>6.8: <a href=#pg-374e5c954990aec58a0797adc70a5039>Topology Aware Hints</a></li><li>6.9: <a href=#pg-9092684b3a27432bc9041d56b7a4a8ba>Networking on Windows</a></li><li>6.10: <a href=#pg-439738e82e994f627155bff468d35404>Service ClusterIP allocation</a></li><li>6.11: <a href=#pg-cd7657b1056ad32451974db57a951ba5>Service Internal Traffic Policy</a></li><li>6.12: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>Topology-aware traffic routing with topology keys</a></li></ul><li>7: <a href=#pg-f018f568c6723865753f150c3c59bdda>Storage</a></li><ul><li>7.1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>Volumes</a></li><li>7.2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>Persistent Volumes</a></li><li>7.3: <a href=#pg-2db414b26d4daec3ebed19dd837830c3>Projected Volumes</a></li><li>7.4: <a href=#pg-df33eab51202c17bb0fe551d1d5cc5d2>Ephemeral Volumes</a></li><li>7.5: <a href=#pg-f0276d05eef111249272a1c932a91e2c>Storage Classes</a></li><li>7.6: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>Dynamic Volume Provisioning</a></li><li>7.7: <a href=#pg-c262af210c6828dec445d2f55a1d877a>Volume Snapshots</a></li><li>7.8: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>Volume Snapshot Classes</a></li><li>7.9: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI Volume Cloning</a></li><li>7.10: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>Storage Capacity</a></li><li>7.11: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>Node-specific Volume Limits</a></li><li>7.12: <a href=#pg-4f40cb95a671e51b4f0156a409d95c6d>Volume Health Monitoring</a></li><li>7.13: <a href=#pg-055a8df536f8ba8f3aa0217bd2db5437>Windows Storage</a></li></ul><li>8: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Configuration</a></li><ul><li>8.1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Configuration Best Practices</a></li><li>8.2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMaps</a></li><li>8.3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secrets</a></li><li>8.4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>Resource Management for Pods and Containers</a></li><li>8.5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizing Cluster Access Using kubeconfig Files</a></li><li>8.6: <a href=#pg-0f628478dbd58516389164933f9d7da2>Resource Management for Windows nodes</a></li></ul><li>9: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>Security</a></li><ul><li>9.1: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>Overview of Cloud Native Security</a></li><li>9.2: <a href=#pg-1fb24c1dd155f43849da490a74c4b8c5>Pod Security Standards</a></li><li>9.3: <a href=#pg-99657bdba0ee6a08e7d2d4dfcb211f37>Service Accounts</a></li><li>9.4: <a href=#pg-bc9934fccfeaf880eec6ea79025c0381>Pod Security Admission</a></li><li>9.5: <a href=#pg-ac71855bb20cbf21edc666e810f4103a>Pod Security Policies</a></li><li>9.6: <a href=#pg-9a68f631b6bc38c279bbc9a145e34ef2>Security For Windows Nodes</a></li><li>9.7: <a href=#pg-4d77d1ae4c06aa14f54b385191627881>Controlling Access to the Kubernetes API</a></li><li>9.8: <a href=#pg-07f58aa0218d666795499c2e2306ff96>Role Based Access Control Good Practices</a></li><li>9.9: <a href=#pg-a7863bfad3d69f33f5b318b9028eecb8>Good practices for Kubernetes Secrets</a></li><li>9.10: <a href=#pg-9dd9b8c71fa39ff803fd15b0e784069d>Multi-tenancy</a></li><li>9.11: <a href=#pg-265c06c3d1349382453ced9f2a7ecfde>Kubernetes API Server Bypass Risks</a></li><li>9.12: <a href=#pg-6f8354561fd5286f997909e14b13110c>Security Checklist</a></li></ul><li>10: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>Policies</a></li><ul><li>10.1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>Limit Ranges</a></li><li>10.2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>Resource Quotas</a></li><li>10.3: <a href=#pg-7352434db5f5954d2f7656b46fe5a324>Process ID Limits And Reservations</a></li><li>10.4: <a href=#pg-b528c4464c030f3f044124b38d778f04>Node Resource Managers</a></li></ul><li>11: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>Scheduling, Preemption and Eviction</a></li><ul><li>11.1: <a href=#pg-598f36d691ab197f9d995784574b0a12>Kubernetes Scheduler</a></li><li>11.2: <a href=#pg-21169f516071aea5d16734a4c27789a5>Assigning Pods to Nodes</a></li><li>11.3: <a href=#pg-da22fe2278df236f71efbe672f392677>Pod Overhead</a></li><li>11.4: <a href=#pg-d9483841860fd8701aee18ffb0759aef>Pod Scheduling Readiness</a></li><li>11.5: <a href=#pg-6b8c85a6a88f4a81e6b79e197c293c31>Pod Topology Spread Constraints</a></li><li>11.6: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>Taints and Tolerations</a></li><li>11.7: <a href=#pg-602208c95fe7b1f1170310ce993f5814>Scheduling Framework</a></li><li>11.8: <a href=#pg-132fdff5faea3a27f280f3acdf4f8b7d>Dynamic Resource Allocation</a></li><li>11.9: <a href=#pg-d9574a30fcbc631b0d2a57850e161e89>Scheduler Performance Tuning</a></li><li>11.10: <a href=#pg-961126cd43559012893979e568396a49>Resource Bin Packing</a></li><li>11.11: <a href=#pg-60e5a2861609e0848d58ce8bf99c4a31>Pod Priority and Preemption</a></li><li>11.12: <a href=#pg-78e0431b4b7516092662a7c289cbb304>Node-pressure Eviction</a></li><li>11.13: <a href=#pg-b87723bf81b079042860f0ebd37b0a64>API-initiated Eviction</a></li></ul><li>12: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Cluster Administration</a></li><ul><li>12.1: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Certificates</a></li><li>12.2: <a href=#pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>Managing Resources</a></li><li>12.3: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>Cluster Networking</a></li><li>12.4: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>Logging Architecture</a></li><li>12.5: <a href=#pg-cbfd3654996eae9fcdef009f70fa83f0>Metrics For Kubernetes System Components</a></li><li>12.6: <a href=#pg-5cc31ecfba86467f8884856412cfb6b2>System Logs</a></li><li>12.7: <a href=#pg-3da54ad355f6fe6574d67bd9a9a42bcb>Traces For Kubernetes System Components</a></li><li>12.8: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Proxies in Kubernetes</a></li><li>12.9: <a href=#pg-31c9327d2332c585341b64ddafa19cdd>API Priority and Fairness</a></li><li>12.10: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Installing Addons</a></li></ul><li>13: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Extending Kubernetes</a></li><ul><li>13.1: <a href=#pg-c8937cdc9df96f3328becf04f8211292>Compute, Storage, and Networking Extensions</a></li><ul><li>13.1.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>Network Plugins</a></li><li>13.1.2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>Device Plugins</a></li></ul><li>13.2: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Extending the Kubernetes API</a></li><ul><li>13.2.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>Custom Resources</a></li><li>13.2.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Kubernetes API Aggregation Layer</a></li></ul><li>13.3: <a href=#pg-3131452556176159fb269593c1a52012>Operator pattern</a></li></ul></ul><div class=content><p>The Concepts section helps you learn about the parts of the Kubernetes system and the abstractions Kubernetes uses to represent your <a class=glossary-tooltip title='A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>, and helps you obtain a deeper understanding of how Kubernetes works.</p></div></div><div class=td-content><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - Overview</h1><div class=lead>Kubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.</div><p>This page is an overview of Kubernetes.</p><p>Kubernetes is a portable, extensible, open source platform for managing containerized
workloads and services, that facilitates both declarative configuration and automation.
It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.</p><p>The name Kubernetes originates from Greek, meaning helmsman or pilot. K8s as an abbreviation
results from counting the eight letters between the "K" and the "s". Google open-sourced the
Kubernetes project in 2014. Kubernetes combines
<a href=/blog/2015/04/borg-predecessor-to-kubernetes/>over 15 years of Google's experience</a> running
production workloads at scale with best-of-breed ideas and practices from the community.</p><h2 id=going-back-in-time>Going back in time</h2><p>Let's take a look at why Kubernetes is so useful by going back in time.</p><p><img src=https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg alt="Deployment evolution"></p><p><strong>Traditional deployment era:</strong>
Early on, organizations ran applications on physical servers. There was no way to define
resource boundaries for applications in a physical server, and this caused resource
allocation issues. For example, if multiple applications run on a physical server, there
can be instances where one application would take up most of the resources, and as a result,
the other applications would underperform. A solution for this would be to run each application
on a different physical server. But this did not scale as resources were underutilized, and it
was expensive for organizations to maintain many physical servers.</p><p><strong>Virtualized deployment era:</strong> As a solution, virtualization was introduced. It allows you
to run multiple Virtual Machines (VMs) on a single physical server's CPU. Virtualization
allows applications to be isolated between VMs and provides a level of security as the
information of one application cannot be freely accessed by another application.</p><p>Virtualization allows better utilization of resources in a physical server and allows
better scalability because an application can be added or updated easily, reduces
hardware costs, and much more. With virtualization you can present a set of physical
resources as a cluster of disposable virtual machines.</p><p>Each VM is a full machine running all the components, including its own operating
system, on top of the virtualized hardware.</p><p><strong>Container deployment era:</strong> Containers are similar to VMs, but they have relaxed
isolation properties to share the Operating System (OS) among the applications.
Therefore, containers are considered lightweight. Similar to a VM, a container
has its own filesystem, share of CPU, memory, process space, and more. As they
are decoupled from the underlying infrastructure, they are portable across clouds
and OS distributions.</p><p>Containers have become popular because they provide extra benefits, such as:</p><ul><li>Agile application creation and deployment: increased ease and efficiency of
container image creation compared to VM image use.</li><li>Continuous development, integration, and deployment: provides for reliable
and frequent container image build and deployment with quick and efficient
rollbacks (due to image immutability).</li><li>Dev and Ops separation of concerns: create application container images at
build/release time rather than deployment time, thereby decoupling
applications from infrastructure.</li><li>Observability: not only surfaces OS-level information and metrics, but also
application health and other signals.</li><li>Environmental consistency across development, testing, and production: runs
the same on a laptop as it does in the cloud.</li><li>Cloud and OS distribution portability: runs on Ubuntu, RHEL, CoreOS, on-premises,
on major public clouds, and anywhere else.</li><li>Application-centric management: raises the level of abstraction from running an
OS on virtual hardware to running an application on an OS using logical resources.</li><li>Loosely coupled, distributed, elastic, liberated micro-services: applications are
broken into smaller, independent pieces and can be deployed and managed dynamically –
not a monolithic stack running on one big single-purpose machine.</li><li>Resource isolation: predictable application performance.</li><li>Resource utilization: high efficiency and density.</li></ul><h2 id=why-you-need-kubernetes-and-what-can-it-do>Why you need Kubernetes and what it can do</h2><p>Containers are a good way to bundle and run your applications. In a production
environment, you need to manage the containers that run the applications and
ensure that there is no downtime. For example, if a container goes down, another
container needs to start. Wouldn't it be easier if this behavior was handled by a system?</p><p>That's how Kubernetes comes to the rescue! Kubernetes provides you with a framework
to run distributed systems resiliently. It takes care of scaling and failover for
your application, provides deployment patterns, and more. For example: Kubernetes
can easily manage a canary deployment for your system.</p><p>Kubernetes provides you with:</p><ul><li><strong>Service discovery and load balancing</strong>
Kubernetes can expose a container using the DNS name or using their own IP address.
If traffic to a container is high, Kubernetes is able to load balance and distribute
the network traffic so that the deployment is stable.</li><li><strong>Storage orchestration</strong>
Kubernetes allows you to automatically mount a storage system of your choice, such as
local storages, public cloud providers, and more.</li><li><strong>Automated rollouts and rollbacks</strong>
You can describe the desired state for your deployed containers using Kubernetes,
and it can change the actual state to the desired state at a controlled rate.
For example, you can automate Kubernetes to create new containers for your
deployment, remove existing containers and adopt all their resources to the new container.</li><li><strong>Automatic bin packing</strong>
You provide Kubernetes with a cluster of nodes that it can use to run containerized tasks.
You tell Kubernetes how much CPU and memory (RAM) each container needs. Kubernetes can fit
containers onto your nodes to make the best use of your resources.</li><li><strong>Self-healing</strong>
Kubernetes restarts containers that fail, replaces containers, kills containers that don't
respond to your user-defined health check, and doesn't advertise them to clients until they
are ready to serve.</li><li><strong>Secret and configuration management</strong>
Kubernetes lets you store and manage sensitive information, such as passwords, OAuth tokens,
and SSH keys. You can deploy and update secrets and application configuration without
rebuilding your container images, and without exposing secrets in your stack configuration.</li></ul><h2 id=what-kubernetes-is-not>What Kubernetes is not</h2><p>Kubernetes is not a traditional, all-inclusive PaaS (Platform as a Service) system.
Since Kubernetes operates at the container level rather than at the hardware level,
it provides some generally applicable features common to PaaS offerings, such as
deployment, scaling, load balancing, and lets users integrate their logging, monitoring,
and alerting solutions. However, Kubernetes is not monolithic, and these default solutions
are optional and pluggable. Kubernetes provides the building blocks for building developer
platforms, but preserves user choice and flexibility where it is important.</p><p>Kubernetes:</p><ul><li>Does not limit the types of applications supported. Kubernetes aims to support an
extremely diverse variety of workloads, including stateless, stateful, and data-processing
workloads. If an application can run in a container, it should run great on Kubernetes.</li><li>Does not deploy source code and does not build your application. Continuous Integration,
Delivery, and Deployment (CI/CD) workflows are determined by organization cultures and
preferences as well as technical requirements.</li><li>Does not provide application-level services, such as middleware (for example, message buses),
data-processing frameworks (for example, Spark), databases (for example, MySQL), caches, nor
cluster storage systems (for example, Ceph) as built-in services. Such components can run on
Kubernetes, and/or can be accessed by applications running on Kubernetes through portable
mechanisms, such as the <a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Does not dictate logging, monitoring, or alerting solutions. It provides some integrations
as proof of concept, and mechanisms to collect and export metrics.</li><li>Does not provide nor mandate a configuration language/system (for example, Jsonnet). It provides
a declarative API that may be targeted by arbitrary forms of declarative specifications.</li><li>Does not provide nor adopt any comprehensive machine configuration, maintenance, management,
or self-healing systems.</li><li>Additionally, Kubernetes is not a mere orchestration system. In fact, it eliminates the need
for orchestration. The technical definition of orchestration is execution of a defined workflow:
first do A, then B, then C. In contrast, Kubernetes comprises a set of independent, composable
control processes that continuously drive the current state towards the provided desired state.
It shouldn't matter how you get from A to C. Centralized control is also not required. This
results in a system that is easier to use and more powerful, robust, resilient, and extensible.</li></ul><h2 id=what-s-next>What's next</h2><ul><li>Take a look at the <a href=/docs/concepts/overview/components/>Kubernetes Components</a></li><li>Take a look at the <a href=/docs/concepts/overview/kubernetes-api/>The Kubernetes API</a></li><li>Take a look at the <a href=/docs/concepts/architecture/>Cluster Architecture</a></li><li>Ready to <a href=/docs/setup/>Get Started</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.1 - Kubernetes Components</h1><div class=lead>A Kubernetes cluster consists of the components that are a part of the control plane and a set of machines called nodes.</div><p>When you deploy Kubernetes, you get a cluster.<p><p>A Kubernetes cluster consists of a set of worker machines, called <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nodes>nodes</a>,
that run containerized applications. Every cluster has at least one worker node.</p></p><p>The worker node(s) host the <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> that are
the components of the application workload. The
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> manages the worker
nodes and the Pods in the cluster. In production environments, the control plane usually
runs across multiple computers and a cluster usually runs multiple nodes, providing
fault-tolerance and high availability.</p></p><p>This document outlines the various components you need to have for
a complete and working Kubernetes cluster.</p><figure class=diagram-large><img src=https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg alt="Components of Kubernetes"><figcaption><p>The components of a Kubernetes cluster</p></figcaption></figure><h2 id=control-plane-components>Control Plane Components</h2><p>The control plane's components make global decisions about the cluster (for example, scheduling), as well as detecting and responding to cluster events (for example, starting up a new <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pod>pod</a> when a deployment's <code>replicas</code> field is unsatisfied).</p><p>Control plane components can be run on any machine in the cluster. However,
for simplicity, set up scripts typically start all control plane components on
the same machine, and do not run user containers on this machine. See
<a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>Creating Highly Available clusters with kubeadm</a>
for an example control plane setup that runs across multiple machines.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>The API server is a component of the Kubernetes
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> that exposes the Kubernetes API.
The API server is the front end for the Kubernetes control plane.</p><p>The main implementation of a Kubernetes API server is <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver is designed to scale horizontally—that is, it scales by deploying more instances.
You can run several instances of kube-apiserver and balance traffic between those instances.</p><h3 id=etcd>etcd</h3><p>Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data.</p><p>If your Kubernetes cluster uses etcd as its backing store, make sure you have a
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>back up</a> plan
for those data.</p><p>You can find in-depth information about etcd in the official <a href=https://etcd.io/docs/>documentation</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Control plane component that watches for newly created
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> with no assigned
<a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>, and selects a node for them
to run on.</p><p>Factors taken into account for scheduling decisions include:
individual and collective resource requirements, hardware/software/policy
constraints, affinity and anti-affinity specifications, data locality,
inter-workload interference, and deadlines.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Control plane component that runs <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> processes.</p><p>Logically, each <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.</p><p>Some types of these controllers are:</p><ul><li>Node controller: Responsible for noticing and responding when nodes go down.</li><li>Job controller: Watches for Job objects that represent one-off tasks, then creates
Pods to run those tasks to completion.</li><li>EndpointSlice controller: Populates EndpointSlice objects (to provide a link between Services and Pods).</li><li>ServiceAccount controller: Create default ServiceAccounts for new namespaces.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>A Kubernetes <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> component
that embeds cloud-specific control logic. The cloud controller manager lets you link your
cluster into your cloud provider's API, and separates out the components that interact
with that cloud platform from components that only interact with your cluster.<p>The cloud-controller-manager only runs controllers that are specific to your cloud provider.
If you are running Kubernetes on your own premises, or in a learning environment inside your
own PC, the cluster does not have a cloud controller manager.</p><p>As with the kube-controller-manager, the cloud-controller-manager combines several logically
independent control loops into a single binary that you run as a single process. You can
scale horizontally (run more than one copy) to improve performance or to help tolerate failures.</p><p>The following controllers can have cloud provider dependencies:</p><ul><li>Node controller: For checking the cloud provider to determine if a node has been deleted in the cloud after it stops responding</li><li>Route controller: For setting up routes in the underlying cloud infrastructure</li><li>Service controller: For creating, updating and deleting cloud provider load balancers</li></ul><h2 id=node-components>Node Components</h2><p>Node components run on every node, maintaining running pods and providing the Kubernetes runtime environment.</p><h3 id=kubelet>kubelet</h3><p>An agent that runs on each <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a> in the cluster. It makes sure that <a class=glossary-tooltip title='A lightweight and portable executable image that contains software and all of its dependencies.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=containers>containers</a> are running in a <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>.</p><p>The kubelet takes a set of PodSpecs that are provided through various mechanisms and ensures that the containers described in those PodSpecs are running and healthy. The kubelet doesn't manage containers which were not created by Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy is a network proxy that runs on each
<a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a> in your cluster,
implementing part of the Kubernetes
<a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> concept.</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
maintains network rules on nodes. These network rules allow network
communication to your Pods from network sessions inside or outside of
your cluster.</p><p>kube-proxy uses the operating system packet filtering layer if there is one
and it's available. Otherwise, kube-proxy forwards the traffic itself.</p><h3 id=container-runtime>Container runtime</h3><p>The container runtime is the software that is responsible for running containers.</p><p>Kubernetes supports container runtimes such as
<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>,
and any other implementation of the <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime
Interface)</a>.</p><h2 id=addons>Addons</h2><p>Addons use Kubernetes resources (<a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>,
<a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, etc)
to implement cluster features. Because these are providing cluster-level features, namespaced resources
for addons belong within the <code>kube-system</code> namespace.</p><p>Selected addons are described below; for an extended list of available addons, please
see <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>While the other addons are not strictly required, all Kubernetes clusters should have <a href=/docs/concepts/services-networking/dns-pod-service/>cluster DNS</a>, as many examples rely on it.</p><p>Cluster DNS is a DNS server, in addition to the other DNS server(s) in your environment, which serves DNS records for Kubernetes services.</p><p>Containers started by Kubernetes automatically include this DNS server in their DNS searches.</p><h3 id=web-ui-dashboard>Web UI (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> is a general purpose, web-based UI for Kubernetes clusters. It allows users to manage and troubleshoot applications running in the cluster, as well as the cluster itself.</p><h3 id=container-resource-monitoring>Container Resource Monitoring</h3><p><a href=/docs/tasks/debug/debug-cluster/resource-usage-monitoring/>Container Resource Monitoring</a> records generic time-series metrics
about containers in a central database, and provides a UI for browsing that data.</p><h3 id=cluster-level-logging>Cluster-level Logging</h3><p>A <a href=/docs/concepts/cluster-administration/logging/>cluster-level logging</a> mechanism is responsible for
saving container logs to a central log store with search/browsing interface.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn about <a href=/docs/concepts/architecture/nodes/>Nodes</a></li><li>Learn about <a href=/docs/concepts/architecture/controller/>Controllers</a></li><li>Learn about <a href=/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a></li><li>Read etcd's official <a href=https://etcd.io/docs/>documentation</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>1.2 - The Kubernetes API</h1><div class=lead>The Kubernetes API lets you query and manipulate the state of objects in Kubernetes. The core of Kubernetes' control plane is the API server and the HTTP API that it exposes. Users, the different parts of your cluster, and external components all communicate with one another through the API server.</div><p>The core of Kubernetes' <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
is the <a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a>. The API server
exposes an HTTP API that lets end users, different parts of your cluster, and
external components communicate with one another.</p><p>The Kubernetes API lets you query and manipulate the state of API objects in Kubernetes
(for example: Pods, Namespaces, ConfigMaps, and Events).</p><p>Most operations can be performed through the
<a href=/docs/reference/kubectl/>kubectl</a> command-line interface or other
command-line tools, such as
<a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>, which in turn use the
API. However, you can also access the API directly using REST calls.</p><p>Consider using one of the <a href=/docs/reference/using-api/client-libraries/>client libraries</a>
if you are writing an application using the Kubernetes API.</p><h2 id=api-specification>OpenAPI specification</h2><p>Complete API details are documented using <a href=https://www.openapis.org/>OpenAPI</a>.</p><h3 id=openapi-v2>OpenAPI V2</h3><p>The Kubernetes API server serves an aggregated OpenAPI v2 spec via the
<code>/openapi/v2</code> endpoint. You can request the response format using
request headers as follows:</p><table><caption style=display:none>Valid request header values for OpenAPI v2 queries</caption><thead><tr><th>Header</th><th style=min-width:50%>Possible values</th><th>Notes</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>not supplying this header is also acceptable</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>mainly for intra-cluster use</em></td></tr><tr><td><code>application/json</code></td><td><em>default</em></td></tr><tr><td><code>*</code></td><td><em>serves </em><code>application/json</code></td></tr></tbody></table><p>Kubernetes implements an alternative Protobuf based serialization format that
is primarily intended for intra-cluster communication. For more information
about this format, see the <a href=https://git.k8s.io/design-proposals-archive/api-machinery/protobuf.md>Kubernetes Protobuf serialization</a> design proposal and the
Interface Definition Language (IDL) files for each schema located in the Go
packages that define the API objects.</p><h3 id=openapi-v3>OpenAPI V3</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [beta]</code></div><p>Kubernetes v1.26 offers beta support for publishing its APIs as OpenAPI v3; this is a
beta feature that is enabled by default.
You can disable the beta feature by turning off the
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> named <code>OpenAPIV3</code>
for the kube-apiserver component.</p><p>A discovery endpoint <code>/openapi/v3</code> is provided to see a list of all
group/versions available. This endpoint only returns JSON. These group/versions
are provided in the following format:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;paths&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;api/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;apis/admissionregistration.k8s.io/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>....<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>The relative URLs are pointing to immutable OpenAPI descriptions, in
order to improve client-side caching. The proper HTTP caching headers
are also set by the API server for that purpose (<code>Expires</code> to 1 year in
the future, and <code>Cache-Control</code> to <code>immutable</code>). When an obsolete URL is
used, the API server returns a redirect to the newest URL.</p><p>The Kubernetes API server publishes an OpenAPI v3 spec per Kubernetes
group version at the <code>/openapi/v3/apis/&lt;group>/&lt;version>?hash=&lt;hash></code>
endpoint.</p><p>Refer to the table below for accepted request headers.</p><table><caption style=display:none>Valid request header values for OpenAPI v3 queries</caption><thead><tr><th>Header</th><th style=min-width:50%>Possible values</th><th>Notes</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>not supplying this header is also acceptable</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td><td><em>mainly for intra-cluster use</em></td></tr><tr><td><code>application/json</code></td><td><em>default</em></td></tr><tr><td><code>*</code></td><td><em>serves </em><code>application/json</code></td></tr></tbody></table><h2 id=persistence>Persistence</h2><p>Kubernetes stores the serialized state of objects by writing them into
<a class=glossary-tooltip title='Consistent and highly-available key value store used as backing store of Kubernetes for all cluster data.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>.</p><h2 id=api-groups-and-versioning>API groups and versioning</h2><p>To make it easier to eliminate fields or restructure resource representations,
Kubernetes supports multiple API versions, each at a different API path, such
as <code>/api/v1</code> or <code>/apis/rbac.authorization.k8s.io/v1alpha1</code>.</p><p>Versioning is done at the API level rather than at the resource or field level
to ensure that the API presents a clear, consistent view of system resources
and behavior, and to enable controlling access to end-of-life and/or
experimental APIs.</p><p>To make it easier to evolve and to extend its API, Kubernetes implements
<a href=/docs/reference/using-api/#api-groups>API groups</a> that can be
<a href=/docs/reference/using-api/#enabling-or-disabling>enabled or disabled</a>.</p><p>API resources are distinguished by their API group, resource type, namespace
(for namespaced resources), and name. The API server handles the conversion between
API versions transparently: all the different versions are actually representations
of the same persisted data. The API server may serve the same underlying data
through multiple API versions.</p><p>For example, suppose there are two API versions, <code>v1</code> and <code>v1beta1</code>, for the same
resource. If you originally created an object using the <code>v1beta1</code> version of its
API, you can later read, update, or delete that object using either the <code>v1beta1</code>
or the <code>v1</code> API version, until the <code>v1beta1</code> version is deprecated and removed.
At that point you can continue accessing and modifying the object using the <code>v1</code> API.</p><h3 id=api-changes>API changes</h3><p>Any system that is successful needs to grow and change as new use cases emerge or existing ones change.
Therefore, Kubernetes has designed the Kubernetes API to continuously change and grow.
The Kubernetes project aims to <em>not</em> break compatibility with existing clients, and to maintain that
compatibility for a length of time so that other projects have an opportunity to adapt.</p><p>In general, new API resources and new resource fields can be added often and frequently.
Elimination of resources or fields requires following the
<a href=/docs/reference/using-api/deprecation-policy/>API deprecation policy</a>.</p><p>Kubernetes makes a strong commitment to maintain compatibility for official Kubernetes APIs
once they reach general availability (GA), typically at API version <code>v1</code>. Additionally,
Kubernetes maintains compatibility with data persisted via <em>beta</em> API versions of official Kubernetes APIs,
and ensures that data can be converted and accessed via GA API versions when the feature goes stable.</p><p>If you adopt a beta API version, you will need to transition to a subsequent beta or stable API version
once the API graduates. The best time to do this is while the beta API is in its deprecation period,
since objects are simultaneously accessible via both API versions. Once the beta API completes its
deprecation period and is no longer served, the replacement API version must be used.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Although Kubernetes also aims to maintain compatibility for <em>alpha</em> APIs versions, in some
circumstances this is not possible. If you use any alpha API versions, check the release notes
for Kubernetes when upgrading your cluster, in case the API did change in incompatible
ways that require deleting all existing alpha objects prior to upgrade.</div><p>Refer to <a href=/docs/reference/using-api/#api-versioning>API versions reference</a>
for more details on the API version level definitions.</p><h2 id=api-extension>API Extension</h2><p>The Kubernetes API can be extended in one of two ways:</p><ol><li><a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom resources</a>
let you declaratively define how the API server should provide your chosen resource API.</li><li>You can also extend the Kubernetes API by implementing an
<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>aggregation layer</a>.</li></ol><h2 id=what-s-next>What's next</h2><ul><li>Learn how to extend the Kubernetes API by adding your own
<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>.</li><li><a href=/docs/concepts/security/controlling-access/>Controlling Access To The Kubernetes API</a> describes
how the cluster manages authentication and authorization for API access.</li><li>Learn about API endpoints, resource types and samples by reading
<a href=/docs/reference/kubernetes-api/>API Reference</a>.</li><li>Learn about what constitutes a compatible change, and how to change the API, from
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>API changes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>1.3 - Working with Kubernetes Objects</h1><div class=lead>Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Learn about the Kubernetes object model and how to work with these objects.</div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1.3.1 - Understanding Kubernetes Objects</h1><p>This page explains how Kubernetes objects are represented in the Kubernetes API, and how you can
express them in <code>.yaml</code> format.</p><h2 id=kubernetes-objects>Understanding Kubernetes objects</h2><p><em>Kubernetes objects</em> are persistent entities in the Kubernetes system. Kubernetes uses these
entities to represent the state of your cluster. Specifically, they can describe:</p><ul><li>What containerized applications are running (and on which nodes)</li><li>The resources available to those applications</li><li>The policies around how those applications behave, such as restart policies, upgrades, and fault-tolerance</li></ul><p>A Kubernetes object is a "record of intent"--once you create the object, the Kubernetes system
will constantly work to ensure that object exists. By creating an object, you're effectively
telling the Kubernetes system what you want your cluster's workload to look like; this is your
cluster's <em>desired state</em>.</p><p>To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the
<a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>. When you use the <code>kubectl</code> command-line
interface, for example, the CLI makes the necessary Kubernetes API calls for you. You can also use
the Kubernetes API directly in your own programs using one of the
<a href=/docs/reference/using-api/client-libraries/>Client Libraries</a>.</p><h3 id=object-spec-and-status>Object spec and status</h3><p>Almost every Kubernetes object includes two nested object fields that govern
the object's configuration: the object <em><code>spec</code></em> and the object <em><code>status</code></em>.
For objects that have a <code>spec</code>, you have to set this when you create the object,
providing a description of the characteristics you want the resource to have:
its <em>desired state</em>.</p><p>The <code>status</code> describes the <em>current state</em> of the object, supplied and updated
by the Kubernetes system and its components. The Kubernetes
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> continually
and actively manages every object's actual state to match the desired state you
supplied.</p><p>For example: in Kubernetes, a Deployment is an object that can represent an
application running on your cluster. When you create the Deployment, you
might set the Deployment <code>spec</code> to specify that you want three replicas of
the application to be running. The Kubernetes system reads the Deployment
spec and starts three instances of your desired application--updating
the status to match your spec. If any of those instances should fail
(a status change), the Kubernetes system responds to the difference
between spec and status by making a correction--in this case, starting
a replacement instance.</p><p>For more information on the object spec, status, and metadata, see the
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a>.</p><h3 id=describing-a-kubernetes-object>Describing a Kubernetes object</h3><p>When you create an object in Kubernetes, you must provide the object spec that describes its
desired state, as well as some basic information about the object (such as a name). When you use
the Kubernetes API to create the object (either directly or via <code>kubectl</code>), that API request must
include that information as JSON in the request body. <strong>Most often, you provide the information to
<code>kubectl</code> in a .yaml file.</strong> <code>kubectl</code> converts the information to JSON when making the API
request.</p><p>Here's an example <code>.yaml</code> file that shows the required fields and object spec for a Kubernetes Deployment:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>One way to create a Deployment using a <code>.yaml</code> file like the one above is to use the
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> command
in the <code>kubectl</code> command-line interface, passing the <code>.yaml</code> file as an argument. Here's an example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>The output is similar to this:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=required-fields>Required fields</h3><p>In the <code>.yaml</code> file for the Kubernetes object you want to create, you'll need to set values for the following fields:</p><ul><li><code>apiVersion</code> - Which version of the Kubernetes API you're using to create this object</li><li><code>kind</code> - What kind of object you want to create</li><li><code>metadata</code> - Data that helps uniquely identify the object, including a <code>name</code> string, <code>UID</code>, and optional <code>namespace</code></li><li><code>spec</code> - What state you desire for the object</li></ul><p>The precise format of the object <code>spec</code> is different for every Kubernetes object, and contains
nested fields specific to that object. The <a href=/docs/reference/kubernetes-api/>Kubernetes API Reference</a>
can help you find the spec format for all of the objects you can create using Kubernetes.</p><p>For example, see the <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> field</a>
for the Pod API reference.
For each Pod, the <code>.spec</code> field specifies the pod and its desired state (such as the container image name for
each container within that pod).
Another example of an object specification is the
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec><code>spec</code> field</a>
for the StatefulSet API. For StatefulSet, the <code>.spec</code> field specifies the StatefulSet and
its desired state.
Within the <code>.spec</code> of a StatefulSet is a <a href=/docs/concepts/workloads/pods/#pod-templates>template</a>
for Pod objects. That template describes Pods that the StatefulSet controller will create in order to
satisfy the StatefulSet specification.
Different kinds of object can also have different <code>.status</code>; again, the API reference pages
detail the structure of that <code>.status</code> field, and its content for each different type of object.</p><h2 id=what-s-next>What's next</h2><p>Learn more about the following:</p><ul><li><a href=/docs/concepts/workloads/pods/>Pods</a> which are the most important basic Kubernetes objects.</li><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a> objects.</li><li><a href=/docs/concepts/architecture/controller/>Controllers</a> in Kubernetes.</li><li><a href=/docs/reference/using-api/>Kubernetes API overview</a> which explains some more API concepts.</li><li><a href=/docs/reference/kubectl/>kubectl</a> and <a href=/docs/reference/generated/kubectl/kubectl-commands>kubectl commands</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>1.3.2 - Kubernetes Object Management</h1><p>The <code>kubectl</code> command-line tool supports several different ways to create and manage
Kubernetes objects. This document provides an overview of the different
approaches. Read the <a href=https://kubectl.docs.kubernetes.io>Kubectl book</a> for
details of managing objects by Kubectl.</p><h2 id=management-techniques>Management techniques</h2><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> A Kubernetes object should be managed using only one technique. Mixing
and matching techniques for the same object results in undefined behavior.</div><table><thead><tr><th>Management technique</th><th>Operates on</th><th>Recommended environment</th><th>Supported writers</th><th>Learning curve</th></tr></thead><tbody><tr><td>Imperative commands</td><td>Live objects</td><td>Development projects</td><td>1+</td><td>Lowest</td></tr><tr><td>Imperative object configuration</td><td>Individual files</td><td>Production projects</td><td>1</td><td>Moderate</td></tr><tr><td>Declarative object configuration</td><td>Directories of files</td><td>Production projects</td><td>1+</td><td>Highest</td></tr></tbody></table><h2 id=imperative-commands>Imperative commands</h2><p>When using imperative commands, a user operates directly on live objects
in a cluster. The user provides operations to
the <code>kubectl</code> command as arguments or flags.</p><p>This is the recommended way to get started or to run a one-off task in
a cluster. Because this technique operates directly on live
objects, it provides no history of previous configurations.</p><h3 id=examples>Examples</h3><p>Run an instance of the nginx container by creating a Deployment object:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=trade-offs>Trade-offs</h3><p>Advantages compared to object configuration:</p><ul><li>Commands are expressed as a single action word.</li><li>Commands require only a single step to make changes to the cluster.</li></ul><p>Disadvantages compared to object configuration:</p><ul><li>Commands do not integrate with change review processes.</li><li>Commands do not provide an audit trail associated with changes.</li><li>Commands do not provide a source of records except for what is live.</li><li>Commands do not provide a template for creating new objects.</li></ul><h2 id=imperative-object-configuration>Imperative object configuration</h2><p>In imperative object configuration, the kubectl command specifies the
operation (create, replace, etc.), optional flags and at least one file
name. The file specified must contain a full definition of the object
in YAML or JSON format.</p><p>See the <a href=/docs/reference/generated/kubernetes-api/v1.26/>API reference</a>
for more details on object definitions.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> The imperative <code>replace</code> command replaces the existing
spec with the newly provided one, dropping all changes to the object missing from
the configuration file. This approach should not be used with resource
types whose specs are updated independently of the configuration file.
Services of type <code>LoadBalancer</code>, for example, have their <code>externalIPs</code> field updated
independently from the configuration by the cluster.</div><h3 id=examples-1>Examples</h3><p>Create the objects defined in a configuration file:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Delete the objects defined in two configuration files:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Update the objects defined in a configuration file by overwriting
the live configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=trade-offs-1>Trade-offs</h3><p>Advantages compared to imperative commands:</p><ul><li>Object configuration can be stored in a source control system such as Git.</li><li>Object configuration can integrate with processes such as reviewing changes before push and audit trails.</li><li>Object configuration provides a template for creating new objects.</li></ul><p>Disadvantages compared to imperative commands:</p><ul><li>Object configuration requires basic understanding of the object schema.</li><li>Object configuration requires the additional step of writing a YAML file.</li></ul><p>Advantages compared to declarative object configuration:</p><ul><li>Imperative object configuration behavior is simpler and easier to understand.</li><li>As of Kubernetes version 1.5, imperative object configuration is more mature.</li></ul><p>Disadvantages compared to declarative object configuration:</p><ul><li>Imperative object configuration works best on files, not directories.</li><li>Updates to live objects must be reflected in configuration files, or they will be lost during the next replacement.</li></ul><h2 id=declarative-object-configuration>Declarative object configuration</h2><p>When using declarative object configuration, a user operates on object
configuration files stored locally, however the user does not define the
operations to be taken on the files. Create, update, and delete operations
are automatically detected per-object by <code>kubectl</code>. This enables working on
directories, where different operations might be needed for different objects.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Declarative object configuration retains changes made by other
writers, even if the changes are not merged back to the object configuration file.
This is possible by using the <code>patch</code> API operation to write only
observed differences, instead of using the <code>replace</code>
API operation to replace the entire object configuration.</div><h3 id=examples-2>Examples</h3><p>Process all object configuration files in the <code>configs</code> directory, and create or
patch the live objects. You can first <code>diff</code> to see what changes are going to be
made, and then apply:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Recursively process directories:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=trade-offs-2>Trade-offs</h3><p>Advantages compared to imperative object configuration:</p><ul><li>Changes made directly to live objects are retained, even if they are not merged back into the configuration files.</li><li>Declarative object configuration has better support for operating on directories and automatically detecting operation types (create, patch, delete) per-object.</li></ul><p>Disadvantages compared to imperative object configuration:</p><ul><li>Declarative object configuration is harder to debug and understand results when they are unexpected.</li><li>Partial updates using diffs create complex merge and patch operations.</li></ul><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Managing Kubernetes Objects Using Imperative Commands</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Imperative Management of Kubernetes Objects Using Configuration Files</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Declarative Management of Kubernetes Objects Using Configuration Files</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Declarative Management of Kubernetes Objects Using Kustomize</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectl Command Reference</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.26/>Kubernetes API Reference</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>1.3.3 - Object Names and IDs</h1><p>Each object in your cluster has a <a href=#names><em>Name</em></a> that is unique for that type of resource.
Every Kubernetes object also has a <a href=#uids><em>UID</em></a> that is unique across your whole cluster.</p><p>For example, you can only have one Pod named <code>myapp-1234</code> within the same <a href=/docs/concepts/overview/working-with-objects/namespaces/>namespace</a>, but you can have one Pod and one Deployment that are each named <code>myapp-1234</code>.</p><p>For non-unique user-provided attributes, Kubernetes provides <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> and <a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=names>Names</h2><p>A client-provided string that refers to an object in a resource URL, such as <code>/api/v1/pods/some-name</code>.</p><p>Only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> In cases when objects represent a physical entity, like a Node representing a physical host, when the host is re-created under the same name without deleting and re-creating the Node, Kubernetes treats the new host as the old one, which may lead to inconsistencies.</div><p>Below are four types of commonly used name constraints for resources.</p><h3 id=dns-subdomain-names>DNS Subdomain Names</h3><p>Most resource types require a name that can be used as a DNS subdomain name
as defined in <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
This means the name must:</p><ul><li>contain no more than 253 characters</li><li>contain only lowercase alphanumeric characters, '-' or '.'</li><li>start with an alphanumeric character</li><li>end with an alphanumeric character</li></ul><h3 id=dns-label-names>RFC 1123 Label Names</h3><p>Some resource types require their names to follow the DNS
label standard as defined in <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
This means the name must:</p><ul><li>contain at most 63 characters</li><li>contain only lowercase alphanumeric characters or '-'</li><li>start with an alphanumeric character</li><li>end with an alphanumeric character</li></ul><h3 id=rfc-1035-label-names>RFC 1035 Label Names</h3><p>Some resource types require their names to follow the DNS
label standard as defined in <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>.
This means the name must:</p><ul><li>contain at most 63 characters</li><li>contain only lowercase alphanumeric characters or '-'</li><li>start with an alphabetic character</li><li>end with an alphanumeric character</li></ul><h3 id=path-segment-names>Path Segment Names</h3><p>Some resource types require their names to be able to be safely encoded as a
path segment. In other words, the name may not be "." or ".." and the name may
not contain "/" or "%".</p><p>Here's an example manifest for a Pod named <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Some resource types have additional restrictions on their names.</div><h2 id=uids>UIDs</h2><p>A Kubernetes systems-generated string to uniquely identify objects.</p><p>Every object created over the whole lifetime of a Kubernetes cluster has a distinct UID. It is intended to distinguish between historical occurrences of similar entities.</p><p>Kubernetes UIDs are universally unique identifiers (also known as UUIDs).
UUIDs are standardized as ISO/IEC 9834-8 and as ITU-T X.667.</p><h2 id=what-s-next>What's next</h2><ul><li>Read about <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> and <a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a> in Kubernetes.</li><li>See the <a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>Identifiers and Names in Kubernetes</a> design document.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>1.3.4 - Labels and Selectors</h1><p><em>Labels</em> are key/value pairs that are attached to objects, such as pods.
Labels are intended to be used to specify identifying attributes of objects
that are meaningful and relevant to users, but do not directly imply semantics
to the core system. Labels can be used to organize and to select subsets of
objects. Labels can be attached to objects at creation time and subsequently
added and modified at any time. Each object can have a set of key/value labels
defined. Each Key must be unique for a given object.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Labels allow for efficient queries and watches and are ideal for use in UIs
and CLIs. Non-identifying information should be recorded using
<a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=motivation>Motivation</h2><p>Labels enable users to map their own organizational structures onto system objects
in a loosely coupled fashion, without requiring clients to store these mappings.</p><p>Service deployments and batch processing pipelines are often multi-dimensional entities
(e.g., multiple partitions or deployments, multiple release tracks, multiple tiers,
multiple micro-services per tier). Management often requires cross-cutting operations,
which breaks encapsulation of strictly hierarchical representations, especially rigid
hierarchies determined by the infrastructure rather than by users.</p><p>Example labels:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>These are examples of
<a href=/docs/concepts/overview/working-with-objects/common-labels/>commonly used labels</a>;
you are free to develop your own conventions.
Keep in mind that label Key must be unique for a given object.</p><h2 id=syntax-and-character-set>Syntax and character set</h2><p><em>Labels</em> are key/value pairs. Valid label keys have two segments: an optional
prefix and name, separated by a slash (<code>/</code>). The name segment is required and
must be 63 characters or less, beginning and ending with an alphanumeric
character (<code>[a-z0-9A-Z]</code>) with dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>),
and alphanumerics between. The prefix is optional. If specified, the prefix
must be a DNS subdomain: a series of DNS labels separated by dots (<code>.</code>),
not longer than 253 characters in total, followed by a slash (<code>/</code>).</p><p>If the prefix is omitted, the label Key is presumed to be private to the user.
Automated system components (e.g. <code>kube-scheduler</code>, <code>kube-controller-manager</code>,
<code>kube-apiserver</code>, <code>kubectl</code>, or other third-party automation) which add labels
to end-user objects must specify a prefix.</p><p>The <code>kubernetes.io/</code> and <code>k8s.io/</code> prefixes are
<a href=/docs/reference/labels-annotations-taints/>reserved</a> for Kubernetes core components.</p><p>Valid label value:</p><ul><li>must be 63 characters or less (can be empty),</li><li>unless empty, must begin and end with an alphanumeric character (<code>[a-z0-9A-Z]</code>),</li><li>could contain dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between.</li></ul><p>For example, here's the configuration file for a Pod that has two labels
<code>environment: production</code> and <code>app: nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=label-selectors>Label selectors</h2><p>Unlike <a href=/docs/concepts/overview/working-with-objects/names/>names and UIDs</a>, labels
do not provide uniqueness. In general, we expect many objects to carry the same label(s).</p><p>Via a <em>label selector</em>, the client/user can identify a set of objects.
The label selector is the core grouping primitive in Kubernetes.</p><p>The API currently supports two types of selectors: <em>equality-based</em> and <em>set-based</em>.
A label selector can be made of multiple <em>requirements</em> which are comma-separated.
In the case of multiple requirements, all must be satisfied so the comma separator
acts as a logical <em>AND</em> (<code>&&</code>) operator.</p><p>The semantics of empty or non-specified selectors are dependent on the context,
and API types that use selectors should document the validity and meaning of
them.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> For some API types, such as ReplicaSets, the label selectors of two instances must
not overlap within a namespace, or the controller can see that as conflicting
instructions and fail to determine how many replicas should be present.</div><div class="alert alert-warning caution callout" role=alert><strong>Caution:</strong> For both equality-based and set-based conditions there is no logical <em>OR</em> (<code>||</code>) operator.
Ensure your filter statements are structured accordingly.</div><h3 id=equality-based-requirement><em>Equality-based</em> requirement</h3><p><em>Equality-</em> or <em>inequality-based</em> requirements allow filtering by label keys and values.
Matching objects must satisfy all of the specified label constraints, though they may
have additional labels as well. Three kinds of operators are admitted <code>=</code>,<code>==</code>,<code>!=</code>.
The first two represent <em>equality</em> (and are synonyms), while the latter represents <em>inequality</em>.
For example:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>The former selects all resources with key equal to <code>environment</code> and value equal to <code>production</code>.
The latter selects all resources with key equal to <code>tier</code> and value distinct from <code>frontend</code>,
and all resources with no labels with the <code>tier</code> key. One could filter for resources in <code>production</code>
excluding <code>frontend</code> using the comma operator: <code>environment=production,tier!=frontend</code></p><p>One usage scenario for equality-based label requirement is for Pods to specify
node selection criteria. For example, the sample Pod below selects nodes with
the label "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=set-based-requirement><em>Set-based</em> requirement</h3><p><em>Set-based</em> label requirements allow filtering keys according to a set of values.
Three kinds of operators are supported: <code>in</code>,<code>notin</code> and <code>exists</code> (only the key identifier).
For example:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul><li>The first example selects all resources with key equal to <code>environment</code> and value
equal to <code>production</code> or <code>qa</code>.</li><li>The second example selects all resources with key equal to <code>tier</code> and values other
than <code>frontend</code> and <code>backend</code>, and all resources with no labels with the <code>tier</code> key.</li><li>The third example selects all resources including a label with key <code>partition</code>;
no values are checked.</li><li>The fourth example selects all resources without a label with key <code>partition</code>;
no values are checked.</li></ul><p>Similarly the comma separator acts as an <em>AND</em> operator. So filtering resources
with a <code>partition</code> key (no matter the value) and with <code>environment</code> different
than <code>qa</code> can be achieved using <code>partition,environment notin (qa)</code>.
The <em>set-based</em> label selector is a general form of equality since
<code>environment=production</code> is equivalent to <code>environment in (production)</code>;
similarly for <code>!=</code> and <code>notin</code>.</p><p><em>Set-based</em> requirements can be mixed with <em>equality-based</em> requirements.
For example: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=list-and-watch-filtering>LIST and WATCH filtering</h3><p>LIST and WATCH operations may specify label selectors to filter the sets of objects
returned using a query parameter. Both requirements are permitted
(presented here as they would appear in a URL query string):</p><ul><li><em>equality-based</em> requirements: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li><em>set-based</em> requirements: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Both label selector styles can be used to list or watch resources via a REST client.
For example, targeting <code>apiserver</code> with <code>kubectl</code> and using <em>equality-based</em> one may write:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>or using <em>set-based</em> requirements:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>As already mentioned <em>set-based</em> requirements are more expressive.
For instance, they can implement the <em>OR</em> operator on values:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>or restricting negative matching via <em>notin</em> operator:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=set-references-in-api-objects>Set references in API objects</h3><p>Some Kubernetes objects, such as <a href=/docs/concepts/services-networking/service/><code>services</code></a>
and <a href=/docs/concepts/workloads/controllers/replicationcontroller/><code>replicationcontrollers</code></a>,
also use label selectors to specify sets of other resources, such as
<a href=/docs/concepts/workloads/pods/>pods</a>.</p><h4 id=service-and-replicationcontroller>Service and ReplicationController</h4><p>The set of pods that a <code>service</code> targets is defined with a label selector.
Similarly, the population of pods that a <code>replicationcontroller</code> should
manage is also defined with a label selector.</p><p>Labels selectors for both objects are defined in <code>json</code> or <code>yaml</code> files using maps,
and only <em>equality-based</em> requirement selectors are supported:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>or</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>This selector (respectively in <code>json</code> or <code>yaml</code> format) is equivalent to
<code>component=redis</code> or <code>component in (redis)</code>.</p><h4 id=resources-that-support-set-based-requirements>Resources that support set-based requirements</h4><p>Newer resources, such as <a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a>,
<a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>,
<a href=/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>, and
<a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>,
support <em>set-based</em> requirements as well.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> is a map of <code>{key,value}</code> pairs. A single <code>{key,value}</code> in the
<code>matchLabels</code> map is equivalent to an element of <code>matchExpressions</code>, whose <code>key</code>
field is "key", the <code>operator</code> is "In", and the <code>values</code> array contains only "value".
<code>matchExpressions</code> is a list of pod selector requirements. Valid operators include
In, NotIn, Exists, and DoesNotExist. The values set must be non-empty in the case of
In and NotIn. All of the requirements, from both <code>matchLabels</code> and <code>matchExpressions</code>
are ANDed together -- they must all be satisfied in order to match.</p><h4 id=selecting-sets-of-nodes>Selecting sets of nodes</h4><p>One use case for selecting over labels is to constrain the set of nodes onto which
a pod can schedule. See the documentation on
<a href=/docs/concepts/scheduling-eviction/assign-pod-node/>node selection</a> for more information.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn how to <a href=/docs/tasks/configure-pod-container/assign-pods-nodes/#add-a-label-to-a-node>add a label to a node</a></li><li>Find <a href=/docs/reference/labels-annotations-taints/>Well-known labels, Annotations and Taints</a></li><li>See <a href=/docs/concepts/overview/working-with-objects/common-labels/>Recommended labels</a></li><li><a href=/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/>Enforce Pod Security Standards with Namespace Labels</a></li><li><a href=/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>Use Labels effectively</a> to manage deployments.</li><li>Read a blog on <a href=/blog/2021/06/21/writing-a-controller-for-pod-labels/>Writing a Controller for Pod Labels</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>1.3.5 - Namespaces</h1><p>In Kubernetes, <em>namespaces</em> provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects <em>(e.g. Deployments, Services, etc)</em> and not for cluster-wide objects <em>(e.g. StorageClass, Nodes, PersistentVolumes, etc)</em>.</p><h2 id=when-to-use-multiple-namespaces>When to Use Multiple Namespaces</h2><p>Namespaces are intended for use in environments with many users spread across multiple
teams, or projects. For clusters with a few to tens of users, you should not
need to create or think about namespaces at all. Start using namespaces when you
need the features they provide.</p><p>Namespaces provide a scope for names. Names of resources need to be unique within a namespace,
but not across namespaces. Namespaces cannot be nested inside one another and each Kubernetes
resource can only be in one namespace.</p><p>Namespaces are a way to divide cluster resources between multiple users (via <a href=/docs/concepts/policy/resource-quotas/>resource quota</a>).</p><p>It is not necessary to use multiple namespaces to separate slightly different
resources, such as different versions of the same software: use
<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a> to distinguish
resources within the same namespace.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> For a production cluster, consider <em>not</em> using the <code>default</code> namespace. Instead, make other namespaces and use those.</div><h2 id=initial-namespaces>Initial namespaces</h2><p>Kubernetes starts with four initial namespaces:</p><dl><dt><code>default</code></dt><dd>Kubernetes includes this namespace so that you can start using your new cluster without first creating a namespace.</dd><dt><code>kube-node-lease</code></dt><dd>This namespace holds <a href=/docs/concepts/architecture/leases/>Lease</a> objects associated with each node. Node leases allow the kubelet to send <a href=/docs/concepts/architecture/nodes/#heartbeats>heartbeats</a> so that the control plane can detect node failure.</dd><dt><code>kube-public</code></dt><dd>This namespace is readable by <em>all</em> clients (including those not authenticated). This namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a requirement.</dd><dt><code>kube-system</code></dt><dd>The namespace for objects created by the Kubernetes system.</dd></dl><h2 id=working-with-namespaces>Working with Namespaces</h2><p>Creation and deletion of namespaces are described in the
<a href=/docs/tasks/administer-cluster/namespaces>Admin Guide documentation for namespaces</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Avoid creating namespaces with the prefix <code>kube-</code>, since it is reserved for Kubernetes system namespaces.</div><h3 id=viewing-namespaces>Viewing namespaces</h3><p>You can list the current namespaces in a cluster using:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><h3 id=setting-the-namespace-for-a-request>Setting the namespace for a request</h3><p>To set the namespace for a current request, use the <code>--namespace</code> flag.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=setting-the-namespace-preference>Setting the namespace preference</h3><p>You can permanently save the namespace for all subsequent kubectl commands in that
context.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Validate it</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=namespaces-and-dns>Namespaces and DNS</h2><p>When you create a <a href=/docs/concepts/services-networking/service/>Service</a>,
it creates a corresponding <a href=/docs/concepts/services-networking/dns-pod-service/>DNS entry</a>.
This entry is of the form <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, which means
that if a container only uses <code>&lt;service-name></code>, it will resolve to the service which
is local to a namespace. This is useful for using the same configuration across
multiple namespaces such as Development, Staging and Production. If you want to reach
across namespaces, you need to use the fully qualified domain name (FQDN).</p><p>As a result, all namespace names must be valid
<a href=/docs/concepts/overview/working-with-objects/names/#dns-label-names>RFC 1123 DNS labels</a>.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong><p>By creating namespaces with the same name as <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>public top-level
domains</a>, Services in these
namespaces can have short DNS names that overlap with public DNS records.
Workloads from any namespace performing a DNS lookup without a <a href=https://datatracker.ietf.org/doc/html/rfc1034#page-8>trailing dot</a> will
be redirected to those services, taking precedence over public DNS.</p><p>To mitigate this, limit privileges for creating namespaces to trusted users. If
required, you could additionally configure third-party security controls, such
as <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>admission
webhooks</a>,
to block creating any namespace with the name of <a href=https://data.iana.org/TLD/tlds-alpha-by-domain.txt>public
TLDs</a>.</p></div><h2 id=not-all-objects-are-in-a-namespace>Not all objects are in a namespace</h2><p>Most Kubernetes resources (e.g. pods, services, replication controllers, and others) are
in some namespaces. However namespace resources are not themselves in a namespace.
And low-level resources, such as
<a href=/docs/concepts/architecture/nodes/>nodes</a> and
<a href=/docs/concepts/storage/persistent-volumes/>persistentVolumes</a>, are not in any namespace.</p><p>To see which Kubernetes resources are and aren't in a namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># In a namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Not in a namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=automatic-labelling>Automatic labelling</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.22 [stable]</code></div><p>The Kubernetes control plane sets an immutable <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=label>label</a>
<code>kubernetes.io/metadata.name</code> on all namespaces, provided that the <code>NamespaceDefaultLabelName</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> is enabled.
The value of the label is the namespace name.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>creating a new namespace</a>.</li><li>Learn more about <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>deleting a namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>1.3.6 - Annotations</h1><p>You can use Kubernetes annotations to attach arbitrary non-identifying metadata
to objects. Clients such as tools and libraries can retrieve this metadata.</p><h2 id=attaching-metadata-to-objects>Attaching metadata to objects</h2><p>You can use either labels or annotations to attach metadata to Kubernetes
objects. Labels can be used to select objects and to find
collections of objects that satisfy certain conditions. In contrast, annotations
are not used to identify and select objects. The metadata
in an annotation can be small or large, structured or unstructured, and can
include characters not permitted by labels.</p><p>Annotations, like labels, are key/value maps:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The keys and the values in the map must be strings. In other words, you cannot use
numeric, boolean, list or other types for either the keys or the values.</div><p>Here are some examples of information that could be recorded in annotations:</p><ul><li><p>Fields managed by a declarative configuration layer. Attaching these fields
as annotations distinguishes them from default values set by clients or
servers, and from auto-generated fields and fields set by
auto-sizing or auto-scaling systems.</p></li><li><p>Build, release, or image information like timestamps, release IDs, git branch,
PR numbers, image hashes, and registry address.</p></li><li><p>Pointers to logging, monitoring, analytics, or audit repositories.</p></li><li><p>Client library or tool information that can be used for debugging purposes:
for example, name, version, and build information.</p></li><li><p>User or tool/system provenance information, such as URLs of related objects
from other ecosystem components.</p></li><li><p>Lightweight rollout tool metadata: for example, config or checkpoints.</p></li><li><p>Phone or pager numbers of persons responsible, or directory entries that
specify where that information can be found, such as a team web site.</p></li><li><p>Directives from the end-user to the implementations to modify behavior or
engage non-standard features.</p></li></ul><p>Instead of using annotations, you could store this type of information in an
external database or directory, but that would make it much harder to produce
shared client libraries and tools for deployment, management, introspection,
and the like.</p><h2 id=syntax-and-character-set>Syntax and character set</h2><p><em>Annotations</em> are key/value pairs. Valid annotation keys have two segments: an optional prefix and name, separated by a slash (<code>/</code>). The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character (<code>[a-z0-9A-Z]</code>) with dashes (<code>-</code>), underscores (<code>_</code>), dots (<code>.</code>), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (<code>.</code>), not longer than 253 characters in total, followed by a slash (<code>/</code>).</p><p>If the prefix is omitted, the annotation Key is presumed to be private to the user. Automated system components (e.g. <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, or other third-party automation) which add annotations to end-user objects must specify a prefix.</p><p>The <code>kubernetes.io/</code> and <code>k8s.io/</code> prefixes are reserved for Kubernetes core components.</p><p>For example, here's the configuration file for a Pod that has the annotation <code>imageregistry: https://hub.docker.com/</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=what-s-next>What's next</h2><p>Learn more about <a href=/docs/concepts/overview/working-with-objects/labels/>Labels and Selectors</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>1.3.7 - Field Selectors</h1><p><em>Field selectors</em> let you <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>select Kubernetes resources</a> based on the value of one or more resource fields. Here are some examples of field selector queries:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>This <code>kubectl</code> command selects all Pods for which the value of the <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> field is <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Field selectors are essentially resource <em>filters</em>. By default, no selectors/filters are applied, meaning that all resources of the specified type are selected. This makes the <code>kubectl</code> queries <code>kubectl get pods</code> and <code>kubectl get pods --field-selector ""</code> equivalent.</div><h2 id=supported-fields>Supported fields</h2><p>Supported field selectors vary by Kubernetes resource type. All resource types support the <code>metadata.name</code> and <code>metadata.namespace</code> fields. Using unsupported field selectors produces an error. For example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=supported-operators>Supported operators</h2><p>You can use the <code>=</code>, <code>==</code>, and <code>!=</code> operators with field selectors (<code>=</code> and <code>==</code> mean the same thing). This <code>kubectl</code> command, for example, selects all Kubernetes Services that aren't in the <code>default</code> namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=chained-selectors>Chained selectors</h2><p>As with <a href=/docs/concepts/overview/working-with-objects/labels>label</a> and other selectors, field selectors can be chained together as a comma-separated list. This <code>kubectl</code> command selects all Pods for which the <code>status.phase</code> does not equal <code>Running</code> and the <code>spec.restartPolicy</code> field equals <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=multiple-resource-types>Multiple resource types</h2><p>You can use field selectors across multiple resource types. This <code>kubectl</code> command selects all Statefulsets and Services that are not in the <code>default</code> namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-13ce5627ef1dc8cbb4530ed231cb7d38>1.3.8 - Finalizers</h1><p>Finalizers are namespaced keys that tell Kubernetes to wait until specific
conditions are met before it fully deletes resources marked for deletion.
Finalizers alert <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>
to clean up resources the deleted object owned.</p><p>When you tell Kubernetes to delete an object that has finalizers specified for
it, the Kubernetes API marks the object for deletion by populating <code>.metadata.deletionTimestamp</code>,
and returns a <code>202</code> status code (HTTP "Accepted"). The target object remains in a terminating state while the
control plane, or other components, take the actions defined by the finalizers.
After these actions are complete, the controller removes the relevant finalizers
from the target object. When the <code>metadata.finalizers</code> field is empty,
Kubernetes considers the deletion complete and deletes the object.</p><p>You can use finalizers to control <a class=glossary-tooltip title='A collective term for the various mechanisms Kubernetes uses to clean up cluster resources.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='garbage collection'>garbage collection</a>
of resources. For example, you can define a finalizer to clean up related resources or
infrastructure before the controller deletes the target resource.</p><p>You can use finalizers to control <a class=glossary-tooltip title='A collective term for the various mechanisms Kubernetes uses to clean up cluster resources.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/garbage-collection/ target=_blank aria-label='garbage collection'>garbage collection</a>
of resources by alerting <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a> to perform specific cleanup tasks before
deleting the target resource.</p><p>Finalizers don't usually specify the code to execute. Instead, they are
typically lists of keys on a specific resource similar to annotations.
Kubernetes specifies some finalizers automatically, but you can also specify
your own.</p><h2 id=how-finalizers-work>How finalizers work</h2><p>When you create a resource using a manifest file, you can specify finalizers in
the <code>metadata.finalizers</code> field. When you attempt to delete the resource, the
API server handling the delete request notices the values in the <code>finalizers</code> field
and does the following:</p><ul><li>Modifies the object to add a <code>metadata.deletionTimestamp</code> field with the
time you started the deletion.</li><li>Prevents the object from being removed until its <code>metadata.finalizers</code> field is empty.</li><li>Returns a <code>202</code> status code (HTTP "Accepted")</li></ul><p>The controller managing that finalizer notices the update to the object setting the
<code>metadata.deletionTimestamp</code>, indicating deletion of the object has been requested.
The controller then attempts to satisfy the requirements of the finalizers
specified for that resource. Each time a finalizer condition is satisfied, the
controller removes that key from the resource's <code>finalizers</code> field. When the
<code>finalizers</code> field is emptied, an object with a <code>deletionTimestamp</code> field set
is automatically deleted. You can also use finalizers to prevent deletion of unmanaged resources.</p><p>A common example of a finalizer is <code>kubernetes.io/pv-protection</code>, which prevents
accidental deletion of <code>PersistentVolume</code> objects. When a <code>PersistentVolume</code>
object is in use by a Pod, Kubernetes adds the <code>pv-protection</code> finalizer. If you
try to delete the <code>PersistentVolume</code>, it enters a <code>Terminating</code> status, but the
controller can't delete it because the finalizer exists. When the Pod stops
using the <code>PersistentVolume</code>, Kubernetes clears the <code>pv-protection</code> finalizer,
and the controller deletes the volume.</p><h2 id=owners-labels-finalizers>Owner references, labels, and finalizers</h2><p>Like <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>,
<a href=/docs/concepts/overview/working-with-objects/owners-dependents/>owner references</a>
describe the relationships between objects in Kubernetes, but are used for a
different purpose. When a
<a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> manages objects
like Pods, it uses labels to track changes to groups of related objects. For
example, when a <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> creates one or
more Pods, the Job controller applies labels to those pods and tracks changes to
any Pods in the cluster with the same label.</p><p>The Job controller also adds <em>owner references</em> to those Pods, pointing at the
Job that created the Pods. If you delete the Job while these Pods are running,
Kubernetes uses the owner references (not labels) to determine which Pods in the
cluster need cleanup.</p><p>Kubernetes also processes finalizers when it identifies owner references on a
resource targeted for deletion.</p><p>In some situations, finalizers can block the deletion of dependent objects,
which can cause the targeted owner object to remain for
longer than expected without being fully deleted. In these situations, you
should check finalizers and owner references on the target owner and dependent
objects to troubleshoot the cause.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> In cases where objects are stuck in a deleting state, avoid manually
removing finalizers to allow deletion to continue. Finalizers are usually added
to resources for a reason, so forcefully removing them can lead to issues in
your cluster. This should only be done when the purpose of the finalizer is
understood and is accomplished in another way (for example, manually cleaning
up some dependent object).</div><h2 id=what-s-next>What's next</h2><ul><li>Read <a href=/blog/2021/05/14/using-finalizers-to-control-deletion/>Using Finalizers to Control Deletion</a>
on the Kubernetes blog.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-efaa7a58910b58892dafd50e3b43c93c>1.3.9 - Owners and Dependents</h1><p>In Kubernetes, some objects are <em>owners</em> of other objects. For example, a
<a class=glossary-tooltip title='ReplicaSet ensures that a specified number of Pod replicas are running at one time' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a> is the owner of a set of Pods. These owned objects are <em>dependents</em>
of their owner.</p><p>Ownership is different from the <a href=/docs/concepts/overview/working-with-objects/labels/>labels and selectors</a>
mechanism that some resources also use. For example, consider a Service that
creates <code>EndpointSlice</code> objects. The Service uses labels to allow the control plane to
determine which <code>EndpointSlice</code> objects are used for that Service. In addition
to the labels, each <code>EndpointSlice</code> that is managed on behalf of a Service has
an owner reference. Owner references help different parts of Kubernetes avoid
interfering with objects they don’t control.</p><h2 id=owner-references-in-object-specifications>Owner references in object specifications</h2><p>Dependent objects have a <code>metadata.ownerReferences</code> field that references their
owner object. A valid owner reference consists of the object name and a UID
within the same namespace as the dependent object. Kubernetes sets the value of
this field automatically for objects that are dependents of other objects like
ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers.
You can also configure these relationships manually by changing the value of
this field. However, you usually don't need to and can allow Kubernetes to
automatically manage the relationships.</p><p>Dependent objects also have an <code>ownerReferences.blockOwnerDeletion</code> field that
takes a boolean value and controls whether specific dependents can block garbage
collection from deleting their owner object. Kubernetes automatically sets this
field to <code>true</code> if a <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>
(for example, the Deployment controller) sets the value of the
<code>metadata.ownerReferences</code> field. You can also set the value of the
<code>blockOwnerDeletion</code> field manually to control which dependents block garbage
collection.</p><p>A Kubernetes admission controller controls user access to change this field for
dependent resources, based on the delete permissions of the owner. This control
prevents unauthorized users from delaying owner object deletion.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Cross-namespace owner references are disallowed by design.
Namespaced dependents can specify cluster-scoped or namespaced owners.
A namespaced owner <strong>must</strong> exist in the same namespace as the dependent.
If it does not, the owner reference is treated as absent, and the dependent
is subject to deletion once all owners are verified absent.</p><p>Cluster-scoped dependents can only specify cluster-scoped owners.
In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner,
it is treated as having an unresolvable owner reference, and is not able to be garbage collected.</p><p>In v1.20+, if the garbage collector detects an invalid cross-namespace <code>ownerReference</code>,
or a cluster-scoped dependent with an <code>ownerReference</code> referencing a namespaced kind, a warning Event
with a reason of <code>OwnerRefInvalidNamespace</code> and an <code>involvedObject</code> of the invalid dependent is reported.
You can check for that kind of Event by running
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id=ownership-and-finalizers>Ownership and finalizers</h2><p>When you tell Kubernetes to delete a resource, the API server allows the
managing controller to process any <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizer rules</a>
for the resource. <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=Finalizers>Finalizers</a>
prevent accidental deletion of resources your cluster may still need to function
correctly. For example, if you try to delete a <code>PersistentVolume</code> that is still
in use by a Pod, the deletion does not happen immediately because the
<code>PersistentVolume</code> has the <code>kubernetes.io/pv-protection</code> finalizer on it.
Instead, the volume remains in the <code>Terminating</code> status until Kubernetes clears
the finalizer, which only happens after the <code>PersistentVolume</code> is no longer
bound to a Pod.</p><p>Kubernetes also adds finalizers to an owner resource when you use either
<a href=/docs/concepts/architecture/garbage-collection/#cascading-deletion>foreground or orphan cascading deletion</a>.
In foreground deletion, it adds the <code>foreground</code> finalizer so that the
controller must delete dependent resources that also have
<code>ownerReferences.blockOwnerDeletion=true</code> before it deletes the owner. If you
specify an orphan deletion policy, Kubernetes adds the <code>orphan</code> finalizer so
that the controller ignores dependent resources after it deletes the owner
object.</p><h2 id=what-s-next>What's next</h2><ul><li>Learn more about <a href=/docs/concepts/overview/working-with-objects/finalizers/>Kubernetes finalizers</a>.</li><li>Learn about <a href=/docs/concepts/architecture/garbage-collection>garbage collection</a>.</li><li>Read the API reference for <a href=/docs/reference/kubernetes-api/common-definitions/object-meta/#System>object metadata</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>1.3.10 - Recommended Labels</h1><p>You can visualize and manage Kubernetes objects with more tools than kubectl and
the dashboard. A common set of labels allows tools to work interoperably, describing
objects in a common manner that all tools can understand.</p><p>In addition to supporting tooling, the recommended labels describe applications
in a way that can be queried.</p><p>The metadata is organized around the concept of an <em>application</em>. Kubernetes is not
a platform as a service (PaaS) and doesn't have or enforce a formal notion of an application.
Instead, applications are informal and described with metadata. The definition of
what an application contains is loose.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> These are recommended labels. They make it easier to manage applications
but aren't required for any core tooling.</div><p>Shared labels and annotations share a common prefix: <code>app.kubernetes.io</code>. Labels
without a prefix are private to users. The shared prefix ensures that shared labels
do not interfere with custom user labels.</p><h2 id=labels>Labels</h2><p>In order to take full advantage of using these labels, they should be applied
on every resource object.</p><table><thead><tr><th>Key</th><th>Description</th><th>Example</th><th>Type</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>The name of the application</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>A unique name identifying the instance of an application</td><td><code>mysql-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>The current version of the application (e.g., a <a href=https://semver.org/spec/v1.0.0.html>SemVer 1.0</a>, revision hash, etc.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>The component within the architecture</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>The name of a higher level application this one is part of</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>The tool being used to manage the operation of an application</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>To illustrate these labels in action, consider the following <a class=glossary-tooltip title='Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a> object:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># This is an excerpt</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=applications-and-instances-of-applications>Applications And Instances Of Applications</h2><p>An application can be installed one or more times into a Kubernetes cluster and,
in some cases, the same namespace. For example, WordPress can be installed more
than once where different websites are different installations of WordPress.</p><p>The name of an application and the instance name are recorded separately. For
example, WordPress has a <code>app.kubernetes.io/name</code> of <code>wordpress</code> while it has
an instance name, represented as <code>app.kubernetes.io/instance</code> with a value of
<code>wordpress-abcxzy</code>. This enables the application and instance of the application
to be identifiable. Every instance of an application must have a unique name.</p><h2 id=examples>Examples</h2><p>To illustrate different ways to use these labels the following examples have varying complexity.</p><h3 id=a-simple-stateless-service>A Simple Stateless Service</h3><p>Consider the case for a simple stateless service deployed using <code>Deployment</code> and <code>Service</code> objects. The following two snippets represent how the labels could be used in their simplest form.</p><p>The <code>Deployment</code> is used to oversee the pods running the application itself.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose the application.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=web-application-with-a-database>Web Application With A Database</h3><p>Consider a slightly more complicated application: a web application (WordPress)
using a database (MySQL), installed using Helm. The following snippets illustrate
the start of objects used to deploy this application.</p><p>The start to the following <code>Deployment</code> is used for WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL is exposed as a <code>StatefulSet</code> with metadata for both it and the larger application it belongs to:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The <code>Service</code> is used to expose MySQL as part of WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>With the MySQL <code>StatefulSet</code> and <code>Service</code> you'll notice information about both MySQL and WordPress, the broader application, are included.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - Cluster Architecture</h1><div class=lead>The architectural concepts behind Kubernetes.</div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>2.1 - Nodes</h1><p>Kubernetes runs your <a class=glossary-tooltip title='A workload is an application running on Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/ target=_blank aria-label=workload>workload</a> by placing containers into Pods to run on <em>Nodes</em>.
A node may be a virtual or physical machine, depending on the cluster. Each node
is managed by the
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
and contains the services necessary to run
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a>.</p><p>Typically you have several nodes in a cluster; in a learning or resource-limited
environment, you might have only one node.</p><p>The <a href=/docs/concepts/overview/components/#node-components>components</a> on a node include the
<a class=glossary-tooltip title='An agent that runs on each node in the cluster. It makes sure that containers are running in a pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>, a
<a class=glossary-tooltip title='The container runtime is the software that is responsible for running containers.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>, and the
<a class=glossary-tooltip title='kube-proxy is a network proxy that runs on each node in the cluster.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=management>Management</h2><p>There are two main ways to have Nodes added to the <a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a>:</p><ol><li>The kubelet on a node self-registers to the control plane</li><li>You (or another human user) manually add a Node object</li></ol><p>After you create a Node <a class=glossary-tooltip title='A entity in the Kubernetes system, representing part of the state of your cluster.' data-toggle=tooltip data-placement=top href=https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects target=_blank aria-label=object>object</a>,
or the kubelet on a node self-registers, the control plane checks whether the new Node object is
valid. For example, if you try to create a Node from the following JSON manifest:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes creates a Node object internally (the representation). Kubernetes checks
that a kubelet has registered to the API server that matches the <code>metadata.name</code>
field of the Node. If the node is healthy (i.e. all necessary services are running),
then it is eligible to run a Pod. Otherwise, that node is ignored for any cluster activity
until it becomes healthy.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>Kubernetes keeps the object for the invalid Node and continues checking to see whether
it becomes healthy.</p><p>You, or a <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>, must explicitly
delete the Node object to stop that health checking.</p></div><p>The name of a Node object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.</p><h3 id=node-name-uniqueness>Node name uniqueness</h3><p>The <a href=/docs/concepts/overview/working-with-objects/names#names>name</a> identifies a Node. Two Nodes
cannot have the same name at the same time. Kubernetes also assumes that a resource with the same
name is the same object. In case of a Node, it is implicitly assumed that an instance using the
same name will have the same state (e.g. network settings, root disk contents)
and attributes like node labels. This may lead to
inconsistencies if an instance was modified without changing its name. If the Node needs to be
replaced or updated significantly, the existing Node object needs to be removed from API server
first and re-added after the update.</p><h3 id=self-registration-of-nodes>Self-registration of Nodes</h3><p>When the kubelet flag <code>--register-node</code> is true (the default), the kubelet will attempt to
register itself with the API server. This is the preferred pattern, used by most distros.</p><p>For self-registration, the kubelet is started with the following options:</p><ul><li><p><code>--kubeconfig</code> - Path to credentials to authenticate itself to the API server.</p></li><li><p><code>--cloud-provider</code> - How to talk to a <a class=glossary-tooltip title='An organization that offers a cloud computing platform.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-cloud-provider' target=_blank aria-label='cloud provider'>cloud provider</a>
to read metadata about itself.</p></li><li><p><code>--register-node</code> - Automatically register with the API server.</p></li><li><p><code>--register-with-taints</code> - Register the node with the given list of
<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a> (comma separated <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>No-op if <code>register-node</code> is false.</p></li><li><p><code>--node-ip</code> - IP address of the node.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Labels>Labels</a> to add when registering the node
in the cluster (see label restrictions enforced by the
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Specifies how often kubelet posts its node status to the API server.</p></li></ul><p>When the <a href=/docs/reference/access-authn-authz/node/>Node authorization mode</a> and
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>
are enabled, kubelets are only authorized to create/modify their own Node resource.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>As mentioned in the <a href=#node-name-uniqueness>Node name uniqueness</a> section,
when Node configuration needs to be updated, it is a good practice to re-register
the node with the API server. For example, if the kubelet being restarted with
the new set of <code>--node-labels</code>, but the same Node name is used, the change will
not take an effect, as labels are being set on the Node registration.</p><p>Pods already scheduled on the Node may misbehave or cause issues if the Node
configuration will be changed on kubelet restart. For example, already running
Pod may be tainted against the new labels assigned to the Node, while other
Pods, that are incompatible with that Pod will be scheduled based on this new
label. Node re-registration ensures all Pods will be drained and properly
re-scheduled.</p></div><h3 id=manual-node-administration>Manual Node administration</h3><p>You can create and modify Node objects using
<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>When you want to create Node objects manually, set the kubelet flag <code>--register-node=false</code>.</p><p>You can modify Node objects regardless of the setting of <code>--register-node</code>.
For example, you can set labels on an existing Node or mark it unschedulable.</p><p>You can use labels on Nodes in conjunction with node selectors on Pods to control
scheduling. For example, you can constrain a Pod to only be eligible to run on
a subset of the available nodes.</p><p>Marking a node as unschedulable prevents the scheduler from placing new pods onto
that Node but does not affect existing Pods on the Node. This is useful as a
preparatory step before a node reboot or other maintenance.</p><p>To mark a Node unschedulable, run:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><p>See <a href=/docs/tasks/administer-cluster/safely-drain-node/>Safely Drain a Node</a>
for more details.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> Pods that are part of a <a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> tolerate
being run on an unschedulable Node. DaemonSets typically provide node-local services
that should run on the Node even if it is being drained of workload applications.</div><h2 id=node-status>Node status</h2><p>A Node's status contains the following information:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Conditions</a></li><li><a href=#capacity>Capacity and Allocatable</a></li><li><a href=#info>Info</a></li></ul><p>You can use <code>kubectl</code> to view a Node's status and other details:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>Each section of the output is described below.</p><h3 id=addresses>Addresses</h3><p>The usage of these fields varies depending on your cloud provider or bare metal configuration.</p><ul><li>HostName: The hostname as reported by the node's kernel. Can be overridden via the kubelet
<code>--hostname-override</code> parameter.</li><li>ExternalIP: Typically the IP address of the node that is externally routable (available from
outside the cluster).</li><li>InternalIP: Typically the IP address of the node that is routable only within the cluster.</li></ul><h3 id=condition>Conditions</h3><p>The <code>conditions</code> field describes the status of all <code>Running</code> nodes. Examples of conditions include:</p><table><caption style=display:none>Node conditions, and a description of when each condition applies.</caption><thead><tr><th>Node Condition</th><th>Description</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> if the node is healthy and ready to accept pods, <code>False</code> if the node is not healthy and is not accepting pods, and <code>Unknown</code> if the node controller has not heard from the node in the last <code>node-monitor-grace-period</code> (default is 40 seconds)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> if pressure exists on the disk size—that is, if the disk capacity is low; otherwise <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> if pressure exists on the node memory—that is, if the node memory is low; otherwise <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> if pressure exists on the processes—that is, if there are too many processes on the node; otherwise <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> if the network for the node is not correctly configured, otherwise <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If you use command-line tools to print details of a cordoned Node, the Condition includes
<code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> is not a Condition in the Kubernetes API; instead,
cordoned nodes are marked Unschedulable in their spec.</div><p>In the Kubernetes API, a node's condition is represented as part of the <code>.status</code>
of the Node resource. For example, the following JSON structure describes a healthy node:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>If the <code>status</code> of the Ready condition remains <code>Unknown</code> or <code>False</code> for longer
than the <code>pod-eviction-timeout</code> (an argument passed to the
<a class=glossary-tooltip title='Control Plane component that runs controller processes.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), then the <a href=#node-controller>node controller</a> triggers
<a class=glossary-tooltip title='API-initiated eviction is the process by which you use the Eviction API to create an Eviction object that triggers graceful pod termination.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='API-initiated eviction'>API-initiated eviction</a>
for all Pods assigned to that node. The default eviction timeout duration is
<strong>five minutes</strong>.
In some cases when the node is unreachable, the API server is unable to communicate
with the kubelet on the node. The decision to delete the pods cannot be communicated to
the kubelet until communication with the API server is re-established. In the meantime,
the pods that are scheduled for deletion may continue to run on the partitioned node.</p><p>The node controller does not force delete pods until it is confirmed that they have stopped
running in the cluster. You can see the pods that might be running on an unreachable node as
being in the <code>Terminating</code> or <code>Unknown</code> state. In cases where Kubernetes cannot deduce from the
underlying infrastructure if a node has permanently left a cluster, the cluster administrator
may need to delete the node object by hand. Deleting the node object from Kubernetes causes
all the Pod objects running on the node to be deleted from the API server and frees up their
names.</p><p>When problems occur on nodes, the Kubernetes control plane automatically creates
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>taints</a> that match the conditions
affecting the node.
The scheduler takes the Node's taints into consideration when assigning a Pod to a Node.
Pods can also have <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=tolerations>tolerations</a> that let
them run on a Node even though it has a specific taint.</p><p>See <a href=/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition>Taint Nodes by Condition</a>
for more details.</p><h3 id=capacity>Capacity and Allocatable</h3><p>Describes the resources available on the node: CPU, memory, and the maximum
number of pods that can be scheduled onto the node.</p><p>The fields in the capacity block indicate the total amount of resources that a
Node has. The allocatable block indicates the amount of resources on a
Node that is available to be consumed by normal Pods.</p><p>You may read more about capacity and allocatable resources while learning how
to <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>reserve compute resources</a>
on a Node.</p><h3 id=info>Info</h3><p>Describes general information about the node, such as kernel version, Kubernetes
version (kubelet and kube-proxy version), container runtime details, and which
operating system the node uses.
The kubelet gathers this information from the node and publishes it into
the Kubernetes API.</p><h2 id=heartbeats>Heartbeats</h2><p>Heartbeats, sent by Kubernetes nodes, help your cluster determine the
availability of each node, and to take action when failures are detected.</p><p>For nodes there are two forms of heartbeats:</p><ul><li>updates to the <code>.status</code> of a Node</li><li><a href=/docs/concepts/architecture/leases/>Lease</a> objects
within the <code>kube-node-lease</code>
<a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Each Node has an associated Lease object.</li></ul><p>Compared to updates to <code>.status</code> of a Node, a Lease is a lightweight resource.
Using Leases for heartbeats reduces the performance impact of these updates
for large clusters.</p><p>The kubelet is responsible for creating and updating the <code>.status</code> of Nodes,
and for updating their related Leases.</p><ul><li>The kubelet updates the node's <code>.status</code> either when there is change in status
or if there has been no update for a configured interval. The default interval
for <code>.status</code> updates to Nodes is 5 minutes, which is much longer than the 40
second default timeout for unreachable nodes.</li><li>The kubelet creates and then updates its Lease object every 10 seconds
(the default update interval). Lease updates occur independently from
updates to the Node's <code>.status</code>. If the Lease update fails, the kubelet retries,
using exponential backoff that starts at 200 milliseconds and capped at 7 seconds.</li></ul><h2 id=node-controller>Node controller</h2><p>The node <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> is a
Kubernetes control plane component that manages various aspects of nodes.</p><p>The node controller has multiple roles in a node's life. The first is assigning a
CIDR block to the node when it is registered (if CIDR assignment is turned on).</p><p>The second is keeping the node controller's internal list of nodes up to date with
the cloud provider's list of available machines. When running in a cloud
environment and whenever a node is unhealthy, the node controller asks the cloud
provider if the VM for that node is still available. If not, the node
controller deletes the node from its list of nodes.</p><p>The third is monitoring the nodes' health. The node controller is
responsible for:</p><ul><li>In the case that a node becomes unreachable, updating the <code>Ready</code> condition
in the Node's <code>.status</code> field. In this case the node controller sets the
<code>Ready</code> condition to <code>Unknown</code>.</li><li>If a node remains unreachable: triggering
<a href=/docs/concepts/scheduling-eviction/api-eviction/>API-initiated eviction</a>
for all of the Pods on the unreachable node. By default, the node controller
waits 5 minutes between marking the node as <code>Unknown</code> and submitting
the first eviction request.</li></ul><p>By default, the node controller checks the state of each node every 5 seconds.
This period can be configured using the <code>--node-monitor-period</code> flag on the
<code>kube-controller-manager</code> component.</p><h3 id=rate-limits-on-eviction>Rate limits on eviction</h3><p>In most cases, the node controller limits the eviction rate to
<code>--node-eviction-rate</code> (default 0.1) per second, meaning it won't evict pods
from more than 1 node per 10 seconds.</p><p>The node eviction behavior changes when a node in a given availability zone
becomes unhealthy. The node controller checks what percentage of nodes in the zone
are unhealthy (the <code>Ready</code> condition is <code>Unknown</code> or <code>False</code>) at
the same time:</p><ul><li>If the fraction of unhealthy nodes is at least <code>--unhealthy-zone-threshold</code>
(default 0.55), then the eviction rate is reduced.</li><li>If the cluster is small (i.e. has less than or equal to
<code>--large-cluster-size-threshold</code> nodes - default 50), then evictions are stopped.</li><li>Otherwise, the eviction rate is reduced to <code>--secondary-node-eviction-rate</code>
(default 0.01) per second.</li></ul><p>The reason these policies are implemented per availability zone is because one
availability zone might become partitioned from the control plane while the others remain
connected. If your cluster does not span multiple cloud provider availability zones,
then the eviction mechanism does not take per-zone unavailability into account.</p><p>A key reason for spreading your nodes across availability zones is so that the
workload can be shifted to healthy zones when one entire zone goes down.
Therefore, if all nodes in a zone are unhealthy, then the node controller evicts at
the normal rate of <code>--node-eviction-rate</code>. The corner case is when all zones are
completely unhealthy (none of the nodes in the cluster are healthy). In such a
case, the node controller assumes that there is some problem with connectivity
between the control plane and the nodes, and doesn't perform any evictions.
(If there has been an outage and some nodes reappear, the node controller does
evict pods from the remaining nodes that are unhealthy or unreachable).</p><p>The node controller is also responsible for evicting pods running on nodes with
<code>NoExecute</code> taints, unless those pods tolerate that taint.
The node controller also adds <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a>
corresponding to node problems like node unreachable or not ready. This means
that the scheduler won't place Pods onto unhealthy nodes.</p><h2 id=node-capacity>Resource capacity tracking</h2><p>Node objects track information about the Node's resource capacity: for example, the amount
of memory available and the number of CPUs.
Nodes that <a href=#self-registration-of-nodes>self register</a> report their capacity during
registration. If you <a href=#manual-node-administration>manually</a> add a Node, then
you need to set the node's capacity information when you add it.</p><p>The Kubernetes <a class=glossary-tooltip title='Control plane component that watches for newly created pods with no assigned node, and selects a node for them to run on.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a> ensures that
there are enough resources for all the Pods on a Node. The scheduler checks that the sum
of the requests of containers on the node is no greater than the node's capacity.
That sum of requests includes all containers managed by the kubelet, but excludes any
containers started directly by the container runtime, and also excludes any
processes running outside of the kubelet's control.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> If you want to explicitly reserve resources for non-Pod processes, see
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>reserve resources for system daemons</a>.</div><h2 id=node-topology>Node topology</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>If you have enabled the <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, then
the kubelet can use topology hints when making resource assignment decisions.
See <a href=/docs/tasks/administer-cluster/topology-manager/>Control Topology Management Policies on a Node</a>
for more information.</p><h2 id=graceful-node-shutdown>Graceful node shutdown</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>The kubelet attempts to detect node system shutdown and terminates pods running on the node.</p><p>Kubelet ensures that pods follow the normal
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>pod termination process</a>
during the node shutdown.</p><p>The Graceful node shutdown feature depends on systemd since it takes advantage of
<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd inhibitor locks</a> to
delay the node shutdown with a given duration.</p><p>Graceful node shutdown is controlled with the <code>GracefulNodeShutdown</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> which is
enabled by default in 1.21.</p><p>Note that by default, both configuration options described below,
<code>shutdownGracePeriod</code> and <code>shutdownGracePeriodCriticalPods</code> are set to zero,
thus not activating the graceful node shutdown functionality.
To activate the feature, the two kubelet config settings should be configured appropriately and
set to non-zero values.</p><p>During a graceful shutdown, kubelet terminates pods in two phases:</p><ol><li>Terminate regular pods running on the node.</li><li>Terminate <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>
running on the node.</li></ol><p>Graceful node shutdown feature is configured with two
<a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a> options:</p><ul><li><code>shutdownGracePeriod</code>:<ul><li>Specifies the total duration that the node should delay the shutdown by. This is the total
grace period for pod termination for both regular and
<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>.</li></ul></li><li><code>shutdownGracePeriodCriticalPods</code>:<ul><li>Specifies the duration used to terminate
<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>
during a node shutdown. This value should be less than <code>shutdownGracePeriod</code>.</li></ul></li></ul><p>For example, if <code>shutdownGracePeriod=30s</code>, and
<code>shutdownGracePeriodCriticalPods=10s</code>, kubelet will delay the node shutdown by
30 seconds. During the shutdown, the first 20 (30-10) seconds would be reserved
for gracefully terminating normal pods, and the last 10 seconds would be
reserved for terminating <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>When pods were evicted during the graceful node shutdown, they are marked as shutdown.
Running <code>kubectl get pods</code> shows the status of the evicted pods as <code>Terminated</code>.
And <code>kubectl describe pod</code> indicates that the pod was evicted because of node shutdown:</p><pre tabindex=0><code>Reason:         Terminated
Message:        Pod was terminated in response to imminent node shutdown.
</code></pre></div><h3 id=pod-priority-graceful-node-shutdown>Pod Priority based graceful node shutdown</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>To provide more flexibility during graceful node shutdown around the ordering
of pods during shutdown, graceful node shutdown honors the PriorityClass for
Pods, provided that you enabled this feature in your cluster. The feature
allows cluster administers to explicitly define the ordering of pods
during graceful node shutdown based on
<a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass>priority classes</a>.</p><p>The <a href=#graceful-node-shutdown>Graceful Node Shutdown</a> feature, as described
above, shuts down pods in two phases, non-critical pods, followed by critical
pods. If additional flexibility is needed to explicitly define the ordering of
pods during shutdown in a more granular way, pod priority based graceful
shutdown can be used.</p><p>When graceful node shutdown honors pod priorities, this makes it possible to do
graceful node shutdown in multiple phases, each phase shutting down a
particular priority class of pods. The kubelet can be configured with the exact
phases and shutdown time per phase.</p><p>Assuming the following custom pod
<a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass>priority classes</a>
in a cluster,</p><table><thead><tr><th>Pod priority class name</th><th>Pod priority class value</th></tr></thead><tbody><tr><td><code>custom-class-a</code></td><td>100000</td></tr><tr><td><code>custom-class-b</code></td><td>10000</td></tr><tr><td><code>custom-class-c</code></td><td>1000</td></tr><tr><td><code>regular/unset</code></td><td>0</td></tr></tbody></table><p>Within the <a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>kubelet configuration</a>
the settings for <code>shutdownGracePeriodByPodPriority</code> could look like:</p><table><thead><tr><th>Pod priority class value</th><th>Shutdown period</th></tr></thead><tbody><tr><td>100000</td><td>10 seconds</td></tr><tr><td>10000</td><td>180 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table><p>The corresponding kubelet config YAML configuration would be:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>shutdownGracePeriodByPodPriority</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>100000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>10000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>180</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>120</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>The above table implies that any pod with <code>priority</code> value >= 100000 will get
just 10 seconds to stop, any pod with value >= 10000 and &lt; 100000 will get 180
seconds to stop, any pod with value >= 1000 and &lt; 10000 will get 120 seconds to stop.
Finally, all other pods will get 60 seconds to stop.</p><p>One doesn't have to specify values corresponding to all of the classes. For
example, you could instead use these settings:</p><table><thead><tr><th>Pod priority class value</th><th>Shutdown period</th></tr></thead><tbody><tr><td>100000</td><td>300 seconds</td></tr><tr><td>1000</td><td>120 seconds</td></tr><tr><td>0</td><td>60 seconds</td></tr></tbody></table><p>In the above case, the pods with <code>custom-class-b</code> will go into the same bucket
as <code>custom-class-c</code> for shutdown.</p><p>If there are no pods in a particular range, then the kubelet does not wait
for pods in that priority range. Instead, the kubelet immediately skips to the
next priority class value range.</p><p>If this feature is enabled and no configuration is provided, then no ordering
action will be taken.</p><p>Using this feature requires enabling the <code>GracefulNodeShutdownBasedOnPodPriority</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
, and setting <code>ShutdownGracePeriodByPodPriority</code> in the
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet config</a>
to the desired configuration containing the pod priority class values and
their respective shutdown periods.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> The ability to take Pod priority into account during graceful node shutdown was introduced
as an Alpha feature in Kubernetes v1.23. In Kubernetes 1.26
the feature is Beta and is enabled by default.</div><p>Metrics <code>graceful_shutdown_start_time_seconds</code> and <code>graceful_shutdown_end_time_seconds</code>
are emitted under the kubelet subsystem to monitor node shutdowns.</p><h2 id=non-graceful-node-shutdown>Non Graceful node shutdown</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.26 [beta]</code></div><p>A node shutdown action may not be detected by kubelet's Node Shutdown Manager,
either because the command does not trigger the inhibitor locks mechanism used by
kubelet or because of a user error, i.e., the ShutdownGracePeriod and
ShutdownGracePeriodCriticalPods are not configured properly. Please refer to above
section <a href=#graceful-node-shutdown>Graceful Node Shutdown</a> for more details.</p><p>When a node is shutdown but not detected by kubelet's Node Shutdown Manager, the pods
that are part of a <a class=glossary-tooltip title='Manages deployment and scaling of a set of Pods, with durable storage and persistent identifiers for each Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a> will be stuck in terminating status on
the shutdown node and cannot move to a new running node. This is because kubelet on
the shutdown node is not available to delete the pods so the StatefulSet cannot
create a new pod with the same name. If there are volumes used by the pods, the
VolumeAttachments will not be deleted from the original shutdown node so the volumes
used by these pods cannot be attached to a new running node. As a result, the
application running on the StatefulSet cannot function properly. If the original
shutdown node comes up, the pods will be deleted by kubelet and new pods will be
created on a different running node. If the original shutdown node does not come up,<br>these pods will be stuck in terminating status on the shutdown node forever.</p><p>To mitigate the above situation, a user can manually add the taint <code>node.kubernetes.io/out-of-service</code> with either <code>NoExecute</code>
or <code>NoSchedule</code> effect to a Node marking it out-of-service.
If the <code>NodeOutOfServiceVolumeDetach</code><a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
is enabled on <a class=glossary-tooltip title='Control Plane component that runs controller processes.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>, and a Node is marked out-of-service with this taint, the
pods on the node will be forcefully deleted if there are no matching tolerations on it and volume
detach operations for the pods terminating on the node will happen immediately. This allows the
Pods on the out-of-service node to recover quickly on a different node.</p><p>During a non-graceful shutdown, Pods are terminated in the two phases:</p><ol><li>Force delete the Pods that do not have matching <code>out-of-service</code> tolerations.</li><li>Immediately perform detach volume operation for such pods.</li></ol><div class="alert alert-info note callout" role=alert><strong>Note:</strong><ul><li>Before adding the taint <code>node.kubernetes.io/out-of-service</code> , it should be verified
that the node is already in shutdown or power off state (not in the middle of
restarting).</li><li>The user is required to manually remove the out-of-service taint after the pods are
moved to a new node and the user has checked that the shutdown node has been
recovered since the user was the one who originally added the taint.</li></ul></div><h2 id=swap-memory>Swap memory management</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>Prior to Kubernetes 1.22, nodes did not support the use of swap memory, and a
kubelet would by default fail to start if swap was detected on a node. In 1.22
onwards, swap memory support can be enabled on a per-node basis.</p><p>To enable swap on a node, the <code>NodeSwap</code> feature gate must be enabled on
the kubelet, and the <code>--fail-swap-on</code> command line flag or <code>failSwapOn</code>
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>configuration setting</a>
must be set to false.</p><div class="alert alert-danger warning callout" role=alert><strong>Warning:</strong> When the memory swap feature is turned on, Kubernetes data such as the content
of Secret objects that were written to tmpfs now could be swapped to disk.</div><p>A user can also optionally configure <code>memorySwap.swapBehavior</code> in order to
specify how a node will use swap memory. For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></span></span></code></pre></div><p>The available configuration options for <code>swapBehavior</code> are:</p><ul><li><code>LimitedSwap</code>: Kubernetes workloads are limited in how much swap they can
use. Workloads on the node not managed by Kubernetes can still swap.</li><li><code>UnlimitedSwap</code>: Kubernetes workloads can use as much swap memory as they
request, up to the system limit.</li></ul><p>If configuration for <code>memorySwap</code> is not specified and the feature gate is
enabled, by default the kubelet will apply the same behaviour as the
<code>LimitedSwap</code> setting.</p><p>The behaviour of the <code>LimitedSwap</code> setting depends if the node is running with
v1 or v2 of control groups (also known as "cgroups"):</p><ul><li><strong>cgroupsv1:</strong> Kubernetes workloads can use any combination of memory and
swap, up to the pod's memory limit, if set.</li><li><strong>cgroupsv2:</strong> Kubernetes workloads cannot use swap memory.</li></ul><p>For more information, and to assist with testing and provide feedback, please
see <a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a> and its
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>design proposal</a>.</p><h2 id=what-s-next>What's next</h2><p>Learn more about the following:</p><ul><li><a href=/docs/concepts/overview/components/#node-components>Components</a> that make up a node.</li><li><a href=/docs/reference/generated/kubernetes-api/v1.26/#node-v1-core>API definition for Node</a>.</li><li><a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node>Node</a> section of the architecture design document.</li><li><a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints and Tolerations</a>.</li><li><a href=/docs/concepts/policy/node-resource-managers/>Node Resource Managers</a>.</li><li><a href=/docs/concepts/configuration/windows-resource-management/>Resource Management for Windows nodes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2.2 - Communication between Nodes and the Control Plane</h1><p>This document catalogs the communication paths between the API server and the Kubernetes cluster.
The intent is to allow users to customize their installation to harden the network configuration
such that the cluster can be run on an untrusted network (or on fully public IPs on a cloud
provider).</p><h2 id=node-to-control-plane>Node to Control Plane</h2><p>Kubernetes has a "hub-and-spoke" API pattern. All API usage from nodes (or the pods they run)
terminates at the API server. None of the other control plane components are designed to expose
remote services. The API server is configured to listen for remote connections on a secure HTTPS
port (typically 443) with one or more forms of client
<a href=/docs/reference/access-authn-authz/authentication/>authentication</a> enabled.
One or more forms of <a href=/docs/reference/access-authn-authz/authorization/>authorization</a> should be
enabled, especially if <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>anonymous requests</a>
or <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>service account tokens</a>
are allowed.</p><p>Nodes should be provisioned with the public root certificate for the cluster such that they can
connect securely to the API server along with valid client credentials. A good approach is that the
client credentials provided to the kubelet are in the form of a client certificate. See
<a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a>
for automated provisioning of kubelet client certificates.</p><p>Pods that wish to connect to the API server can do so securely by leveraging a service account so
that Kubernetes will automatically inject the public root certificate and a valid bearer token
into the pod when it is instantiated.
The <code>kubernetes</code> service (in <code>default</code> namespace) is configured with a virtual IP address that is
redirected (via <code>kube-proxy</code>) to the HTTPS endpoint on the API server.</p><p>The control plane components also communicate with the API server over the secure port.</p><p>As a result, the default operating mode for connections from the nodes and pods running on the
nodes to the control plane is secured by default and can run over untrusted and/or public
networks.</p><h2 id=control-plane-to-node>Control plane to node</h2><p>There are two primary communication paths from the control plane (the API server) to the nodes.
The first is from the API server to the kubelet process which runs on each node in the cluster.
The second is from the API server to any node, pod, or service through the API server's <em>proxy</em>
functionality.</p><h3 id=api-server-to-kubelet>API server to kubelet</h3><p>The connections from the API server to the kubelet are used for:</p><ul><li>Fetching logs for pods.</li><li>Attaching (usually through <code>kubectl</code>) to running pods.</li><li>Providing the kubelet's port-forwarding functionality.</li></ul><p>These connections terminate at the kubelet's HTTPS endpoint. By default, the API server does not
verify the kubelet's serving certificate, which makes the connection subject to man-in-the-middle
attacks and <strong>unsafe</strong> to run over untrusted and/or public networks.</p><p>To verify this connection, use the <code>--kubelet-certificate-authority</code> flag to provide the API
server with a root certificate bundle to use to verify the kubelet's serving certificate.</p><p>If that is not possible, use <a href=#ssh-tunnels>SSH tunneling</a> between the API server and kubelet if
required to avoid connecting over an
untrusted or public network.</p><p>Finally, <a href=/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet authentication and/or authorization</a>
should be enabled to secure the kubelet API.</p><h3 id=api-server-to-nodes-pods-and-services>API server to nodes, pods, and services</h3><p>The connections from the API server to a node, pod, or service default to plain HTTP connections
and are therefore neither authenticated nor encrypted. They can be run over a secure HTTPS
connection by prefixing <code>https:</code> to the node, pod, or service name in the API URL, but they will
not validate the certificate provided by the HTTPS endpoint nor provide client credentials. So
while the connection will be encrypted, it will not provide any guarantees of integrity. These
connections <strong>are not currently safe</strong> to run over untrusted or public networks.</p><h3 id=ssh-tunnels>SSH tunnels</h3><p>Kubernetes supports SSH tunnels to protect the control plane to nodes communication paths. In this
configuration, the API server initiates an SSH tunnel to each node in the cluster (connecting to
the SSH server listening on port 22) and passes all traffic destined for a kubelet, node, pod, or
service through the tunnel.
This tunnel ensures that the traffic is not exposed outside of the network in which the nodes are
running.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> SSH tunnels are currently deprecated, so you shouldn't opt to use them unless you know what you
are doing. The <a href=#konnectivity-service>Konnectivity service</a> is a replacement for this
communication channel.</div><h3 id=konnectivity-service>Konnectivity service</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>As a replacement to the SSH tunnels, the Konnectivity service provides TCP level proxy for the
control plane to cluster communication. The Konnectivity service consists of two parts: the
Konnectivity server in the control plane network and the Konnectivity agents in the nodes network.
The Konnectivity agents initiate connections to the Konnectivity server and maintain the network
connections.
After enabling the Konnectivity service, all control plane to nodes traffic goes through these
connections.</p><p>Follow the <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivity service task</a> to set
up the Konnectivity service in your cluster.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>2.3 - Controllers</h1><p>In robotics and automation, a <em>control loop</em> is
a non-terminating loop that regulates the state of a system.</p><p>Here is one example of a control loop: a thermostat in a room.</p><p>When you set the temperature, that's telling the thermostat
about your <em>desired state</em>. The actual room temperature is the
<em>current state</em>. The thermostat acts to bring the current state
closer to the desired state, by turning equipment on or off.</p>In Kubernetes, controllers are control loops that watch the state of your
<a class=glossary-tooltip title='A set of worker machines, called nodes, that run containerized applications. Every cluster has at least one worker node.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>, then make or request
changes where needed.
Each controller tries to move the current cluster state closer to the desired
state.<h2 id=controller-pattern>Controller pattern</h2><p>A controller tracks at least one Kubernetes resource type.
These <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>objects</a>
have a spec field that represents the desired state. The
controller(s) for that resource are responsible for making the current
state come closer to that desired state.</p><p>The controller might carry the action out itself; more commonly, in Kubernetes,
a controller will send messages to the
<a class=glossary-tooltip title='Control plane component that serves the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a> that have
useful side effects. You'll see examples of this below.</p><h3 id=control-via-api-server>Control via API server</h3><p>The <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> controller is an example of a
Kubernetes built-in controller. Built-in controllers manage state by
interacting with the cluster API server.</p><p>Job is a Kubernetes resource that runs a
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, or perhaps several Pods, to carry out
a task and then stop.</p><p>(Once <a href=/docs/concepts/scheduling-eviction/>scheduled</a>, Pod objects become part of the
desired state for a kubelet).</p><p>When the Job controller sees a new task it makes sure that, somewhere
in your cluster, the kubelets on a set of Nodes are running the right
number of Pods to get the work done.
The Job controller does not run any Pods or containers
itself. Instead, the Job controller tells the API server to create or remove
Pods.
Other components in the
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
act on the new information (there are new Pods to schedule and run),
and eventually the work is done.</p><p>After you create a new Job, the desired state is for that Job to be completed.
The Job controller makes the current state for that Job be nearer to your
desired state: creating Pods that do the work you wanted for that Job, so that
the Job is closer to completion.</p><p>Controllers also update the objects that configure them.
For example: once the work is done for a Job, the Job controller
updates that Job object to mark it <code>Finished</code>.</p><p>(This is a bit like how some thermostats turn a light off to
indicate that your room is now at the temperature you set).</p><h3 id=direct-control>Direct control</h3><p>In contrast with Job, some controllers need to make changes to
things outside of your cluster.</p><p>For example, if you use a control loop to make sure there
are enough <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a>
in your cluster, then that controller needs something outside the
current cluster to set up new Nodes when needed.</p><p>Controllers that interact with external state find their desired state from
the API server, then communicate directly with an external system to bring
the current state closer in line.</p><p>(There actually is a <a href=https://github.com/kubernetes/autoscaler/>controller</a>
that horizontally scales the nodes in your cluster.)</p><p>The important point here is that the controller makes some changes to bring about
your desired state, and then reports the current state back to your cluster's API server.
Other control loops can observe that reported data and take their own actions.</p><p>In the thermostat example, if the room is very cold then a different controller
might also turn on a frost protection heater. With Kubernetes clusters, the control
plane indirectly works with IP address management tools, storage services,
cloud provider APIs, and other services by
<a href=/docs/concepts/extend-kubernetes/>extending Kubernetes</a> to implement that.</p><h2 id=desired-vs-current>Desired versus current state</h2><p>Kubernetes takes a cloud-native view of systems, and is able to handle
constant change.</p><p>Your cluster could be changing at any point as work happens and
control loops automatically fix failures. This means that,
potentially, your cluster never reaches a stable state.</p><p>As long as the controllers for your cluster are running and able to make
useful changes, it doesn't matter if the overall state is stable or not.</p><h2 id=design>Design</h2><p>As a tenet of its design, Kubernetes uses lots of controllers that each manage
a particular aspect of cluster state. Most commonly, a particular control loop
(controller) uses one kind of resource as its desired state, and has a different
kind of resource that it manages to make that desired state happen. For example,
a controller for Jobs tracks Job objects (to discover new work) and Pod objects
(to run the Jobs, and then to see when the work is finished). In this case
something else creates the Jobs, whereas the Job controller creates Pods.</p><p>It's useful to have simple controllers rather than one, monolithic set of control
loops that are interlinked. Controllers can fail, so Kubernetes is designed to
allow for that.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong><p>There can be several controllers that create or update the same kind of object.
Behind the scenes, Kubernetes controllers make sure that they only pay attention
to the resources linked to their controlling resource.</p><p>For example, you can have Deployments and Jobs; these both create Pods.
The Job controller does not delete the Pods that your Deployment created,
because there is information (<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>)
the controllers can use to tell those Pods apart.</p></div><h2 id=running-controllers>Ways of running controllers</h2><p>Kubernetes comes with a set of built-in controllers that run inside
the <a class=glossary-tooltip title='Control Plane component that runs controller processes.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. These
built-in controllers provide important core behaviors.</p><p>The Deployment controller and Job controller are examples of controllers that
come as part of Kubernetes itself ("built-in" controllers).
Kubernetes lets you run a resilient control plane, so that if any of the built-in
controllers were to fail, another part of the control plane will take over the work.</p><p>You can find controllers that run outside the control plane, to extend Kubernetes.
Or, if you want, you can write a new controller yourself.
You can run your own controller as a set of Pods,
or externally to Kubernetes. What fits best will depend on what that particular
controller does.</p><h2 id=what-s-next>What's next</h2><ul><li>Read about the <a href=/docs/concepts/overview/components/#control-plane-components>Kubernetes control plane</a></li><li>Discover some of the basic <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>Kubernetes objects</a></li><li>Learn more about the <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>If you want to write your own controller, see
<a href=/docs/concepts/extend-kubernetes/#extension-patterns>Extension Patterns</a>
in Extending Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d5e64235fa89f107957072cd8a39e4c5>2.4 - Leases</h1><p>Distributed systems often have a need for <em>leases</em>, which provide a mechanism to lock shared resources
and coordinate activity between members of a set.
In Kubernetes, the lease concept is represented by <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a>
objects in the <code>coordination.k8s.io</code> <a class=glossary-tooltip title='A set of related paths in the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API Group'>API Group</a>,
which are used for system-critical capabilities such as node heartbeats and component-level leader election.</p><h2 id=node-heart-beats>Node heartbeats</h2><p>Kubernetes uses the Lease API to communicate kubelet node heartbeats to the Kubernetes API server.
For every <code>Node</code> , there is a <code>Lease</code> object with a matching name in the <code>kube-node-lease</code>
namespace. Under the hood, every kubelet heartbeat is an <strong>update</strong> request to this <code>Lease</code> object, updating
the <code>spec.renewTime</code> field for the Lease. The Kubernetes control plane uses the time stamp of this field
to determine the availability of this <code>Node</code>.</p><p>See <a href=/docs/concepts/architecture/nodes/#heartbeats>Node Lease objects</a> for more details.</p><h2 id=leader-election>Leader election</h2><p>Kubernetes also uses Leases to ensure only one instance of a component is running at any given time.
This is used by control plane components like <code>kube-controller-manager</code> and <code>kube-scheduler</code> in
HA configurations, where only one instance of the component should be actively running while the other
instances are on stand-by.</p><h2 id=api-server-identity>API server identity</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.26 [beta]</code></div><p>Starting in Kubernetes v1.26, each <code>kube-apiserver</code> uses the Lease API to publish its identity to the
rest of the system. While not particularly useful on its own, this provides a mechanism for clients to
discover how many instances of <code>kube-apiserver</code> are operating the Kubernetes control plane.
Existence of kube-apiserver leases enables future capabilities that may require coordination between
each kube-apiserver.</p><p>You can inspect Leases owned by each kube-apiserver by checking for lease objects in the <code>kube-system</code> namespace
with the name <code>kube-apiserver-&lt;sha256-hash></code>. Alternatively you can use the label selector <code>k8s.io/component=kube-apiserver</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n kube-system get lease -l k8s.io/component<span style=color:#666>=</span>kube-apiserver
</span></span></code></pre></div><pre tabindex=0><code>NAME                                        HOLDER                                                                           AGE
kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a   kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a_9cbf54e5-1136-44bd-8f9a-1dcd15c346b4   5m33s
kube-apiserver-dz2dqprdpsgnm756t5rnov7yka   kube-apiserver-dz2dqprdpsgnm756t5rnov7yka_84f2a85d-37c1-4b14-b6b9-603e62e4896f   4m23s
kube-apiserver-fyloo45sdenffw2ugwaz3likua   kube-apiserver-fyloo45sdenffw2ugwaz3likua_c5ffa286-8a9a-45d4-91e7-61118ed58d2e   4m43s
</code></pre><p>The SHA256 hash used in the lease name is based on the OS hostname as seen by that API server. Each kube-apiserver should be
configured to use a hostname that is unique within the cluster. New instances of kube-apiserver that use the same hostname
will take over existing Leases using a new holder identity, as opposed to instantiating new Lease objects. You can check the
hostname used by kube-apisever by checking the value of the <code>kubernetes.io/hostname</code> label:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n kube-system get lease kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>coordination.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Lease<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-11-30T15:37:15Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s.io/component</span>:<span style=color:#bbb> </span>kube-apiserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kind-control-plane<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;18171&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d6c68901-4ec5-4385-b1ef-2d783738da6c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>holderIdentity</span>:<span style=color:#bbb> </span>kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a_9cbf54e5-1136-44bd-8f9a-1dcd15c346b4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>leaseDurationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>renewTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2022-11-30T18:04:27.912073Z&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Expired leases from kube-apiservers that no longer exist are garbage collected by new kube-apiservers after 1 hour.</p><p>You can disable API server identity leases by disabling the <code>APIServerIdentity</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>.</p><h2 id=custom-workload>Workloads</h2><p>Your own workload can define its own use of Leases. For example, you might run a custom
<a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> where a primary or leader member
performs operations that its peers do not. You define a Lease so that the controller replicas can select
or elect a leader, using the Kubernetes API for coordination.
If you do use a Lease, it's a good practice to define a name for the Lease that is obviously linked to
the product or component. For example, if you have a component named Example Foo, use a Lease named
<code>example-foo</code>.</p><p>If a cluster operator or another end user could deploy multiple instances of a component, select a name
prefix and pick a mechanism (such as hash of the name of the Deployment) to avoid name collisions
for the Leases.</p><p>You can use another approach so long as it achieves the same outcome: different software products do
not conflict with one another.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.5 - Cloud Controller Manager</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Cloud infrastructure technologies let you run Kubernetes on public, private, and hybrid clouds.
Kubernetes believes in automated, API-driven infrastructure without tight coupling between
components.</p><p><p>The cloud-controller-manager is a Kubernetes <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> component
that embeds cloud-specific control logic. The cloud controller manager lets you link your
cluster into your cloud provider's API, and separates out the components that interact
with that cloud platform from components that only interact with your cluster.</p></p><p>By decoupling the interoperability logic between Kubernetes and the underlying cloud
infrastructure, the cloud-controller-manager component enables cloud providers to release
features at a different pace compared to the main Kubernetes project.</p><p>The cloud-controller-manager is structured using a plugin
mechanism that allows different cloud providers to integrate their platforms with Kubernetes.</p><h2 id=design>Design</h2><p><img src=https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg alt="Kubernetes components"></p><p>The cloud controller manager runs in the control plane as a replicated set of processes
(usually, these are containers in Pods). Each cloud-controller-manager implements
multiple <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a> in a single
process.</p><div class="alert alert-info note callout" role=alert><strong>Note:</strong> You can also run the cloud controller manager as a Kubernetes
<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a> rather than as part
of the control plane.</div><h2 id=functions-of-the-ccm>Cloud controller manager functions</h2><p>The controllers inside the cloud controller manager include:</p><h3 id=node-controller>Node controller</h3><p>The node controller is responsible for updating <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> objects
when new servers are created in your cloud infrastructure. The node controller obtains information about the
hosts running inside your tenancy with the cloud provider. The node controller performs the following functions:</p><ol><li>Update a Node object with the corresponding server's unique identifier obtained from the cloud provider API.</li><li>Annotating and labelling the Node object with cloud-specific information, such as the region the node
is deployed into and the resources (CPU, memory, etc) that it has available.</li><li>Obtain the node's hostname and network addresses.</li><li>Verifying the node's health. In case a node becomes unresponsive, this controller checks with
your cloud provider's API to see if the server has been deactivated / deleted / terminated.
If the node has been deleted from the cloud, the controller deletes the Node object from your Kubernetes
cluster.</li></ol><p>Some cloud provider implementations split this into a node controller and a separate node
lifecycle controller.</p><h3 id=route-controller>Route controller</h3><p>The route controller is responsible for configuring routes in the cloud
appropriately so that containers on different nodes in your Kubernetes
cluster can communicate with each other.</p><p>Depending on the cloud provider, the route controller might also allocate blocks
of IP addresses for the Pod network.</p><h3 id=service-controller>Service controller</h3><p><a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a> integrate with cloud
infrastructure components such as managed load balancers, IP addresses, network
packet filtering, and target health checking. The service controller interacts with your
cloud provider's APIs to set up load balancers and other infrastructure components
when you declare a Service resource that requires them.</p><h2 id=authorization>Authorization</h2><p>This section breaks down the access that the cloud controller manager requires
on various API objects, in order to perform its operations.</p><h3 id=authorization-node-controller>Node controller</h3><p>The Node controller only works with Node objects. It requires full access
to read and modify Node objects.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>Route controller</h3><p>The route controller listens to Node object creation and configures
routes appropriately. It requires Get access to Node objects.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>Service controller</h3><p>The service controller listens to Service object Create, Update and Delete events and then configures Endpoints for those Services appropriately (for EndpointSlices, the kube-controller-manager manages these on demand).</p><p>To access Services, it requires List, and Watch access. To update Services, it requires Patch and Update access.</p><p>To set up Endpoints resources for the Services, it requires access to Create, List, Get, Watch, and Update.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>Others</h3><p>The implementation of the core of the cloud controller manager requires access to create Event objects, and to ensure secure operation, it requires access to create ServiceAccounts.</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p>The <a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRole for the cloud
controller manager looks like:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=what-s-next>What's next</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Cloud Controller Manager Administration</a>
has instructions on running and managing the cloud controller manager.</p><p>To upgrade a HA control plane to use the cloud controller manager, see <a href=/docs/tasks/administer-cluster/controller-manager-leader-migration/>Migrate Replicated Control Plane To Use Cloud Controller Manager</a>.</p><p>Want to know how to implement your own cloud controller manager, or extend an existing project?</p><p>The cloud controller manager uses Go interfaces to allow implementations from any cloud to be plugged in. Specifically, it uses the <code>CloudProvider</code> interface defined in <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a> from <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>.</p><p>The implementation of the shared controllers highlighted in this document (Node, Route, and Service), and some scaffolding along with the shared cloudprovider interface, is part of the Kubernetes core. Implementations specific to cloud providers are outside the core of Kubernetes and implement the <code>CloudProvider</code> interface.</p><p>For more information about developing plugins, see <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>.</p></div><div class=td-content style=page-break-before:always>